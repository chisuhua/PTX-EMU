// =============================================================================
// PTX Statement Type Definition (X-Macro Format)
// Format: X(enum_value, type_name, lowercase_string, op_count)
// Note: op_count = number of operands in the statement (dst + src1 + src2 + ...)
// =============================================================================
// X macro field: statement_type, op_kind, op_name , op_count, struct_kind

// -----------------------------------------------------------------------------
// 0. 基础结果指令（通常不作为完整指令，而是操作数）
// Note: These are not executable instructions; used as operand kinds.
// They typically appear in op[] of other statements, not as standalone stmt.
// For safety, set op_count=0 or exclude from handler generation.
// But to keep consistency, we assign minimal op_count=1 (just for structure).
// In practice, they should NOT be registered as InstructionHandler.
// -----------------------------------------------------------------------------
X(S_REG,     REG,     reg,     0, OPERAND_REG)      // Register reference
X(S_CONST,   CONST,   const,   0, OPERAND_CONST)      // Constant value
X(S_SHARED,  SHARED,  shared,  0, OPERAND_MEMORY)      // Shared memory address
X(S_LOCAL,   LOCAL,   local,   0, OPERAND_MEMORY)      // Local memory address
X(S_DOLLOR,  DOLLOR,  dollar,  0, SIMPLE_NAME)      // Inline register ($r1)

// -----------------------------------------------------------------------------
// 1. 特殊指令
// -----------------------------------------------------------------------------
X(S_AT,      AT,      at,      0, PREDICATE_PREFIX)      // Predicate prefix (not a full instruction)
X(S_PRAGMA,  PRAGMA,  pragma,  0, SIMPLE_STRING)      // Pragma: no operands in PTX sense

// -----------------------------------------------------------------------------
// 2. 控制指令（Control Flow）
// -----------------------------------------------------------------------------
X(S_RET,     RET,     ret,     0, VOID_INSTR)      // Return: no operands
X(S_BRA,     BRA,     bra,     1, BRANCH)      // Branch: target label

// -----------------------------------------------------------------------------
// 3. 同步指令
// -----------------------------------------------------------------------------
X(S_BAR,     BAR,     bar,     0, BARRIER)      // barrier: no operands (simplified)

// -----------------------------------------------------------------------------
// 3. 数据移动与转换（Data Movement & Conversion）
// -----------------------------------------------------------------------------
X(S_LD,      LD,      Ld,      2, GENERIC_INSTR)      // ld: dst, src_addr
X(S_ST,      ST,      St,      2, GENERIC_INSTR)      // st: dst_addr, src
X(S_MOV,     MOV,     Mov,     2, GENERIC_INSTR)      // mov: dst, src
X(S_CVT,     CVT,     Cvt,     2, GENERIC_INSTR)      // cvt: dst, src
X(S_CVTA,    CVTA,    Cvta,    2, GENERIC_INSTR)      // cvta: dst, src

// -----------------------------------------------------------------------------
// 4. 算术运算（Arithmetic Instructions）
// -----------------------------------------------------------------------------
X(S_ADD,     ADD,     Add,     3, GENERIC_INSTR)      // add: dst, src1, src2
X(S_SUB,     SUB,     Sub,     3, GENERIC_INSTR)      // sub: dst, src1, src2
X(S_MUL,     MUL,     Mul,     3, GENERIC_INSTR)      // mul: dst, src1, src2
X(S_MUL24,   MUL24,   Mul24,   3, GENERIC_INSTR)      // mul24: dst, src1, src2
X(S_DIV,     DIV,     Div,     3, GENERIC_INSTR)      // div: dst, src1, src2
X(S_REM,     REM,     Rem,     3, GENERIC_INSTR)      // rem: dst, src1, src2
X(S_MIN,     MIN,     Min,     3, GENERIC_INSTR)      // min: dst, src1, src2
X(S_MAX,     MAX,     Max,     3, GENERIC_INSTR)      // max: dst, src1, src2
X(S_NEG,     NEG,     Neg,     2, GENERIC_INSTR)      // neg: dst, src
X(S_ABS,     ABS,     Abs,     2, GENERIC_INSTR)      // abs: dst, src
X(S_MAD,     MAD,     Mad,     4, GENERIC_INSTR)      // mad: dst, src1, src2, src3 (a*b + c)
X(S_MAD24,   MAD24,   Mad24,   4, GENERIC_INSTR)      // mad24: dst, src1, src2, src3
X(S_FMA,     FMA,     Fma,     4, GENERIC_INSTR)      // fma: dst, src1, src2, src3
X(S_ADDC,    ADDC,    Addc,    3, GENERIC_INSTR)      // addc: dst, src1, src2 (with carry)
X(S_SUBC,    SUBC,    Subc,    3, GENERIC_INSTR)      // subc: dst, src1, src2 (with borrow)

// -----------------------------------------------------------------------------
// 5. 位运算（Bitwise Instructions）
// -----------------------------------------------------------------------------
X(S_AND,     AND,     And,     3, GENERIC_INSTR)      // and: dst, src1, src2
X(S_OR,      OR,      Or,      3, GENERIC_INSTR)      // or: dst, src1, src2
X(S_XOR,     XOR,     Xor,     3, GENERIC_INSTR)      // xor: dst, src1, src2
X(S_NOT,     NOT,     Not,     2, GENERIC_INSTR)      // not: dst, src
X(S_SHL,     SHL,     Shl,     3, GENERIC_INSTR)      // shl: dst, src, shift_amount
X(S_SHR,     SHR,     Shr,     3, GENERIC_INSTR)      // shr: dst, src, shift_amount

// -----------------------------------------------------------------------------
// 6. 比较与选择（Comparison & Selection）
// -----------------------------------------------------------------------------
X(S_SETP,    SETP,    Setp,    3, GENERIC_INSTR)      // setp: pred, src1, src2
X(S_SELP,    SELP,    Selp,    4, GENERIC_INSTR)      // selp: dst, src1, src2, pred

// -----------------------------------------------------------------------------
// 7. 数学函数（Mathematical Functions）
// -----------------------------------------------------------------------------
X(S_SIN,     SIN,     Sin,     2, GENERIC_INSTR)      // sin: dst, src
X(S_COS,     COS,     Cos,     2, GENERIC_INSTR)      // cos: dst, src
X(S_LG2,     LG2,     Lg2,     2, GENERIC_INSTR)      // lg2: dst, src
X(S_EX2,     EX2,     Ex2,     2, GENERIC_INSTR)      // ex2: dst, src
X(S_RCP,     RCP,     Rcp,     2, GENERIC_INSTR)      // rcp: dst, src
X(S_RSQRT,   RSQRT,   Rsqrt,   2, GENERIC_INSTR)      // rsqrt: dst, src
X(S_SQRT,    SQRT,    Sqrt,    2, GENERIC_INSTR)      // sqrt: dst, src

// -----------------------------------------------------------------------------
// 8. 原子操作与特殊指令（Atomic & Special Operations）
// -----------------------------------------------------------------------------
X(S_ATOM,    ATOM,    Atom,    3, ATOM_INSTR)      // atom: dst_addr, src, [optional op] → simplified as 3
X(S_WMMA,    WMMA,    Wmma,    4, WMMA_INSTR)      // wmma: dst, src_a, src_b, src_c (or more, simplified)

// -----------------------------------------------------------------------------
// 9. 位计数与前导零（Bit Manipulation Utilities）
// -----------------------------------------------------------------------------
X(S_POPC,    POPC,    Popc,    2, GENERIC_INSTR)      // popc: dst, src
X(S_CLZ,     CLZ,     Clz,     2, GENERIC_INSTR)      // clz: dst, src


// =============================================================================
// End of statement_types.def
// Note:
// - S_UNKNOWN is intentionally excluded.
// - op_count includes ALL operands (dst, src1, src2, ...).
// - For instructions with optional operands (e.g., atom, wmma), a simplified count is used.
//   You may adjust based on your parser's actual operand count.
// =============================================================================