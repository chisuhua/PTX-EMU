// =============================================================================
// PTX Statement Type Definition (X-Macro Format)
// Format: X(enum_value, type_name, lowercase_string, op_count, struct_kind)
// =============================================================================
// X macro field: statement_type, op_kind, op_name , op_count, struct_kind

// -----------------------------------------------------------------------------
// 0. 基础结果指令（通常不作为完整指令，而是操作数）
// Note: These are not executable instructions; used as operand kinds.
// They typically appear in op[] of other statements, not as standalone stmt.
// For safety, set op_count=0 or exclude from handler generation.
// But to keep consistency, we assign minimal op_count=1 (just for structure).
// In practice, they should NOT be registered as InstructionHandler.
// -----------------------------------------------------------------------------
X(S_REG,     REG,     Reg,     0, OPERAND_REG, structure)      // Register reference
X(S_CONST,   CONST,   Const,   0, OPERAND_CONST, structure)      // Constant value
X(S_SHARED,  SHARED,  Shared,  0, OPERAND_MEMORY, structure)      // Shared memory address
X(S_LOCAL,   LOCAL,   Local,   0, OPERAND_MEMORY, structure)      // Local memory address
X(S_GLOBAL,  GLOBAL,  Global,  0, OPERAND_MEMORY, structure)      // Global memory address
X(S_PARAM,  PARAM,  Param,  0, OPERAND_MEMORY, structure)      // Param memory address
X(S_DOLLOR,  DOLLOR,  Dollar,  0, SIMPLE_NAME, structure)      // Inline register ($r1)

// -----------------------------------------------------------------------------
// 1. 特殊指令
// -----------------------------------------------------------------------------
// X(S_AT,      AT,      At,      0, BRANCH)      // Predicate prefix - conditional execution
X(S_PRAGMA,  PRAGMA,  Pragma,  0, SIMPLE_STRING, structure)      // Pragma: no operands in PTX sense
X(S_LABEL,   LABEL,   Label,   1, LABEL_INSTR, structure)      // Label definition: name:

// -----------------------------------------------------------------------------
// 2. 控制指令（Control Flow）
// -----------------------------------------------------------------------------
X(S_RET,     RET,     Ret,     0, VOID_INSTR, controlFlow)      // Return: no operands
X(S_EXIT,    EXIT,    Exit,    0, VOID_INSTR, controlFlow)      // Exit: terminate kernel
X(S_BRA,     BRA,     Bra,     1, BRANCH, controlFlow)      // Branch: target label
X(S_BRX,     BRX,     Brx,     2, BRANCH, controlFlow)      // Indirect branch: address, target
X(S_CALL,    CALL,    Call,    3, CALL_INSTR, controlFlow)      // Call: function name, args, return addr
X(S_TRAP,    TRAP,    Trap,    0, VOID_INSTR, controlFlow)      // Trap: debug breakpoint
X(S_BRK,     BRK,     Brk,     1, VOID_INSTR, controlFlow)      // Break: with optional number
X(S_BRKPT,   BRKPT,   Brkpt,   0, VOID_INSTR, controlFlow)      // Breakpoint

// -----------------------------------------------------------------------------
// 3. 同步指令
// -----------------------------------------------------------------------------
X(S_BAR,     BAR,     Bar,     2, BARRIER, parallelSync)      // barrier: sync/arrive/red, bar_id
X(S_MEMBAR,  MEMBAR,  Membar,  1, MEMBAR_INSTR, parallelSync)      // membar: scope
X(S_FENCE,   FENCE,   Fence,   1, FENCE_INSTR, parallelSync)      // fence: memory order + scope
X(S_REDUX_SYNC, REDUX_SYNC, ReduxSync, 2, REDUX_INSTR, parallelSync)      // redux.sync: op, dst, src
X(S_MBARRIER_INIT, MBARRIER_INIT, MbarrierInit, 2, MBARRIER_INSTR, parallelSync)      // mbarrier.init
X(S_MBARRIER_ARRIVE, MBARRIER_ARRIVE, MbarrierArrive, 2, MBARRIER_INSTR, parallelSync)      // mbarrier.arrive
X(S_MBARRIER_TRY_WAIT, MBARRIER_TRY_WAIT, MbarrierTryWait, 3, MBARRIER_INSTR, parallelSync)      // mbarrier.try_wait

// -----------------------------------------------------------------------------
// 3. 数据移动与转换（Data Movement & Conversion）
// -----------------------------------------------------------------------------
X(S_LD,      ld,      Ld,      2, GENERIC_INSTR, DataMovement)      // ld: dst, src_addr
X(S_ST,      st,      St,      2, GENERIC_INSTR, DataMovement)      // st: dst_addr, src
X(S_MOV,     mov,     Mov,     2, GENERIC_INSTR, DataMovement)      // mov: dst, src
X(S_CVT,     cvt,     Cvt,     2, GENERIC_INSTR, DataMovement)      // cvt: dst, src
X(S_CVTA,    cvta,    Cvta,    2, GENERIC_INSTR, DataMovement)      // cvta: dst, src
X(S_PRMT,    prmt,    Prmt,    4, GENERIC_INSTR, DataMovement)      // prmt: dst, src1, src2, src3
X(S_ISSPACEP, isspacep, Isspacep, 2, GENERIC_INSTR, DataMovement)      // isspacep: dst, src
X(S_MAPA,    mapa,    Mapa,    3, GENERIC_INSTR, DataMovement)      // mapa: dst, src1, src2
X(S_ALLOCA,  alloca, Alloca,  2, GENERIC_INSTR, DataMovement)      // alloca: dst, size
X(S_CP_ASYNC, cpAsync, CpAsync, 3, CP_ASYNC_INSTR, DataMovement)      // cp.async: dst, src, size

// -----------------------------------------------------------------------------
// 4. 算术运算（Arithmetic Instructions）
// -----------------------------------------------------------------------------
X(S_ADD,     add,     Add,     3, GENERIC_INSTR, arithmetic)      // add: dst, src1, src2
X(S_SUB,     sub,     Sub,     3, GENERIC_INSTR, arithmetic)      // sub: dst, src1, src2
X(S_MUL,     mul,     Mul,     3, GENERIC_INSTR, arithmetic)      // mul: dst, src1, src2
X(S_MUL24,   mul24,   Mul24,   3, GENERIC_INSTR, arithmetic)      // mul24: dst, src1, src2
X(S_DIV,     div,     Div,     3, GENERIC_INSTR, arithmetic)      // div: dst, src1, src2
X(S_REM,     rem,     Rem,     3, GENERIC_INSTR, arithmetic)      // rem: dst, src1, src2
X(S_MIN,     min,     Min,     3, GENERIC_INSTR, arithmetic)      // min: dst, src1, src2
X(S_MAX,     max,     Max,     3, GENERIC_INSTR, arithmetic)      // max: dst, src1, src2
X(S_NEG,     neg,     Neg,     2, GENERIC_INSTR, arithmetic)      // neg: dst, src
X(S_ABS,     abs,     Abs,     2, GENERIC_INSTR, arithmetic)      // abs: dst, src
X(S_MAD,     mad,     Mad,     4, GENERIC_INSTR, arithmetic)      // mad: dst, src1, src2, src3 (a*b + c)
X(S_MAD24,   mad24,   Mad24,   4, GENERIC_INSTR, arithmetic)      // mad24: dst, src1, src2, src3
X(S_FMA,     fma,     Fma,     4, GENERIC_INSTR, arithmetic)      // fma: dst, src1, src2, src3
X(S_ADDC,    addc,    Addc,    3, GENERIC_INSTR, arithmetic)      // addc: dst, src1, src2 (with carry)
X(S_SUBC,    subc,    Subc,    3, GENERIC_INSTR, arithmetic)      // subc: dst, src1, src2 (with borrow)
X(S_SAD,     sad,     Sad,     4, GENERIC_INSTR, arithmetic)      // sad: dst, src1, src2, src3 (sum of absolute differences)
X(S_COPYSIGN, copysign, Copysign, 3, GENERIC_INSTR, arithmetic)      // copysign: dst, src1, src2
X(S_TESTP,   testp,   Testp,   2, GENERIC_INSTR, arithmetic)      // testp: dst, src
X(S_TANH,    tanh,    Tanh,    2, GENERIC_INSTR, arithmetic)      // tanh: dst, src

// -----------------------------------------------------------------------------
// 5. 位运算（Bitwise Instructions）
// -----------------------------------------------------------------------------
X(S_AND,     and,     And,     3, GENERIC_INSTR, logical)      // and: dst, src1, src2
X(S_OR,      or,      Or,      3, GENERIC_INSTR, logical)      // or: dst, src1, src2
X(S_XOR,     xor,     Xor,     3, GENERIC_INSTR, logical)      // xor: dst, src1, src2
X(S_NOT,     not,     Not,     2, GENERIC_INSTR, logical)      // not: dst, src
X(S_SHL,     shl,     Shl,     3, GENERIC_INSTR, logical)      // shl: dst, src, shift_amount
X(S_SHR,     shr,     Shr,     3, GENERIC_INSTR, logical)      // shr: dst, src, shift_amount
X(S_SHF,     shf,     Shf,     4, GENERIC_INSTR, logical)      // shf: dst, src1, src2, shift_amount
X(S_LOP3,    lop3,    Lop3,    5, GENERIC_INSTR, logical)      // lop3: dst, src1, src2, src3, imm

// -----------------------------------------------------------------------------
// 6. 比较与选择（Comparison & Selection）
// -----------------------------------------------------------------------------
X(S_SETP,    setp,    Setp,    3, GENERIC_INSTR, logical)      // setp: pred, src1, src2
X(S_SET,     set,     Set,     3, GENERIC_INSTR, logical)      // set: dst, src1, src2
X(S_SELP,    selp,    Selp,    4, GENERIC_INSTR, logical)      // selp: dst, src1, src2, pred
X(S_SLCT,    slct,    Slct,    4, GENERIC_INSTR, logical)      // slct: dst, src1, src2, pred
X(S_CNOT,    cnot,    Cnot,    2, GENERIC_INSTR, logical)      // cnot: dst, src

// -----------------------------------------------------------------------------
// 7. 数学函数（Mathematical Functions）
// -----------------------------------------------------------------------------
X(S_SIN,     SIN,     Sin,     2, GENERIC_INSTR, arithmetic)      // sin: dst, src
X(S_COS,     COS,     Cos,     2, GENERIC_INSTR, arithmetic)      // cos: dst, src
X(S_LG2,     LG2,     Lg2,     2, GENERIC_INSTR, arithmetic)      // lg2: dst, src
X(S_EX2,     EX2,     Ex2,     2, GENERIC_INSTR, arithmetic)      // ex2: dst, src
X(S_RCP,     RCP,     Rcp,     2, GENERIC_INSTR, arithmetic)      // rcp: dst, src
X(S_RSQRT,   RSQRT,   Rsqrt,   2, GENERIC_INSTR, arithmetic)      // rsqrt: dst, src
X(S_SQRT,    SQRT,    Sqrt,    2, GENERIC_INSTR, arithmetic)      // sqrt: dst, src

// -----------------------------------------------------------------------------
// 8. 原子操作与特殊指令（Atomic & Special Operations）
// -----------------------------------------------------------------------------
X(S_ATOM,    ATOM,    Atom,    3, ATOM_INSTR, atomic)      // atom: dst_addr, src, [optional op] → simplified as 3
X(S_WMMA,    WMMA,    Wmma,    4, WMMA_INSTR, matrix)      // wmma: dst, src_a, src_b, src_c (or more, simplified)

// -----------------------------------------------------------------------------
// 9. 位计数与前导零（Bit Manipulation Utilities）
// -----------------------------------------------------------------------------
X(S_POPC,    POPC,    Popc,    2, GENERIC_INSTR, arithmetic)      // popc: dst, src
X(S_CLZ,     CLZ,     Clz,     2, GENERIC_INSTR, arithmetic)      // clz: dst, src

// -----------------------------------------------------------------------------
// 10. Warp-level Instructions
// -----------------------------------------------------------------------------
X(S_VOTE,    VOTE,    Vote,    2, VOTE_INSTR, warpLevel)      // vote: mode, pred
X(S_SHFL,    SHFL,    Shfl,    4, SHFL_INSTR, warpLevel)      // shfl: mode, dst, src, offset

// -----------------------------------------------------------------------------
// 11. Texture / Surface Instructions
// -----------------------------------------------------------------------------
X(S_TEX,     TEX,     Tex,     2, TEXTURE_INSTR, textureSurface)      // tex: dst, sampler
X(S_SURF,    SURF,    Surf,    2, SURFACE_INSTR, textureSurface)      // surf: dst, surface
X(S_TEX_LDG, TEX_LDG, TexLdg,  2, TEXTURE_INSTR, textureSurface)      // tex.ldg: dst, coord
X(S_TEX_GRAD, TEX_GRAD, TexGrad, 3, TEXTURE_INSTR, textureSurface)      // tex.grad: dst, coord, grad
X(S_TEX_LOD, TEX_LOD, TexLod,  2, TEXTURE_INSTR, textureSurface)      // tex.lod: dst, coord
X(S_TXQ,     TXQ,     Txq,     2, TEXTURE_INSTR, textureSurface)      // txq: dst, query
X(S_SULD,    SULD,    Suld,    2, SURFACE_INSTR, textureSurface)      // suld: dst, addr
X(S_SUST,    SUST,    Sust,    2, SURFACE_INSTR, textureSurface)      // sust: addr, src
X(S_SUQ,     SUQ,     Suq,     2, SURFACE_INSTR, textureSurface)      // suq: dst, query

// -----------------------------------------------------------------------------
// 12. Reduction & Prefetch Instructions
// -----------------------------------------------------------------------------
X(S_RED,     RED,     Red,     3, REDUCTION_INSTR,  reductionPrefetch)      // red: op, addr, val
X(S_PREFETCH, PREFETCH, Prefetch, 1, PREFETCH_INSTR,  reductionPrefetch)      // prefetch: addr
X(S_PREFETCHU, PREFETCHU, Prefetchu, 1, PREFETCH_INSTR, reductionPrefetch)      // prefetchu: addr

// -----------------------------------------------------------------------------
// 13. 异步内存指令（PTX 8.7+）
// -----------------------------------------------------------------------------
X(S_ST_ASYNC,   ST_ASYNC,   StAsync,   2, ASYNC_STORE, tcgen)      // st.async space.type [qualifiers] addr, val
X(S_RED_ASYNC,  RED_ASYNC,  RedAsync,  3, ASYNC_REDUCE, tcgen)     // red.async space.op.type [qualifiers] addr, val[, old]

// -----------------------------------------------------------------------------
// 14. Tensor Core Generator (Hopper+, PTX 8.7+)
// -----------------------------------------------------------------------------
X(S_TCGEN_ALLOC,        TCGEN_ALLOC,        TcgenAlloc,        1, TCGEN_INSTR, tcgen)
X(S_TCGEN_DEALLOC,      TCGEN_DEALLOC,      TcgenDealloc,      1, TCGEN_INSTR, tcgen)
X(S_TCGEN_RELINQUISH,   TCGEN_RELINQUISH,   TcgenRelinquish,   1, TCGEN_INSTR, tcgen)
X(S_TCGEN_CP,           TCGEN_CP,           TcgenCp,           2, TCGEN_INSTR, tcgen)
X(S_TCGEN_SHIFT,        TCGEN_SHIFT,        TcgenShift,        2, TCGEN_INSTR, tcgen)
X(S_TCGEN_MMA,          TCGEN_MMA,          TcgenMma,          4, TCGEN_INSTR, tcgen)
X(S_TCGEN_COMMIT,       TCGEN_COMMIT,       TcgenCommit,       2, TCGEN_INSTR, tcgen)

// -----------------------------------------------------------------------------
// 15. Tensor Map Instructions (PTX 8.7+)
// -----------------------------------------------------------------------------
X(S_TENSORMAP_REPLACE, TENSORMAP_REPLACE, TensormapReplace, 3, TENSORMAP_INSTR, tcgen)

// -----------------------------------------------------------------------------
// 16. Bulk Store (PTX 9.0+)
// -----------------------------------------------------------------------------
X(S_ST_BULK, ST_BULK, StBulk, 3, GENERIC_INSTR, tcgen)

// -----------------------------------------------------------------------------
// 17. ABI Preserve Directives (Global or in func body)
// Note: We treat as statement for uniformity, though usually global
// -----------------------------------------------------------------------------
X(S_ABI_PRESERVE, ABI_PRESERVE, AbiPreserve, 1, ABI_DIRECTIVE, Abi)

// =============================================================================
// End of ptx_op.def
// Note:
// - S_UNKNOWN is intentionally excluded.
// - op_count includes ALL operands (dst, src1, src2, ...).
// - For instructions with optional operands (e.g., atom, wmma), a simplified count is used.
//   You may adjust based on your parser's actual operand count.
// =============================================================================
