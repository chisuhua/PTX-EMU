# PTX 指令语法参考文档（PTX ISA 9.1）  
## 9.7.17–9.7.19 栈操作、视频指令与杂项指令

> 章节对照：https://docs.nvidia.com/cuda/parallel-thread-execution/index.html  
> 说明：本文件提供**指令索引 + 要点**，完整语义以官方文档为准。

## 快速索引（本节覆盖指令）
- 栈/局部内存相关：`alloca`、`ld.local`/`st.local` 与 `%sp` 约定
- 视频指令：详见 [docs/ptx/9.7.18_video.md](9.7.18_video.md)
- 杂项/调试：`trap`, `brkpt` 以及常见特殊寄存器读写

---

## 9.7.17 栈操作指令（Stack Manipulation Instructions）

> PTX 支持软件管理的调用栈，用于函数调用、局部变量分配和递归（若硬件支持）。栈指针寄存器为 `%sp`（32 位或 64 位，取决于地址空间模型）。

### 通用规则
- **栈方向**：向下增长（高地址 → 低地址）
- **对齐要求**：通常 8 字节或 16 字节对齐
- **栈空间来源**：
  - **本地内存（Local Memory）**：由驱动分配，通过 `.local` 地址空间访问
  - **显式分配**：通过 `alloca` 在运行时分配

---

### 1. `mov` + `%sp` — 栈指针读写
```ptx
mov.u64 %rd1, %sp;    // 读取当前栈指针
mov.u64 %sp, %rd2;    // 设置新栈指针（危险！）
```
- **用途**：保存/恢复栈帧、实现协程
- **警告**：直接修改 `%sp` 需极度谨慎，易导致崩溃

---

### 2. `ld.local` / `st.local` — 栈内存访问
```ptx
st.local.f32 [%sp + -4], %f1;  // 存储到栈上（偏移为负）
ld.local.f32 %f2, [%sp + -4];  // 从栈加载
```
- **说明**：
  - 栈位于 `.local` 地址空间
  - 偏移通常为负（因栈向下增长）
- **对齐**：访问必须自然对齐（如 `.f32` → 4B 对齐）

---

### 3. `alloca` — 动态栈分配（PTX ISA 8.0+）
```ptx
alloca.space.size d, n;
```
- **功能**：在栈上分配 `n * size` 字节，返回起始地址
- **空间限定符**：
  - `.local`：分配到本地内存（最常见）
  - `.shared::cluster`：Hopper 上分配到集群共享内存
- **示例**：
  ```ptx
  alloca.local.align.u32.d32 %rd1, 16;  // 分配 16*4=64 字节，对齐到 4B
  ```
- **自动释放**：分配内存在函数返回时自动释放

> ⚠️ **注意**：`alloca` 不是传统意义上的“指令”，而是编译器内置原语，常被优化为 `%sp` 调整。

---

### 4. 栈帧管理（手动实现）
```ptx
// 函数入口：保存旧栈帧，分配新空间
mov.u64 %r_old_sp, %sp;
sub.u64 %sp, %sp, 64;        // 分配 64 字节
st.local.u64 [%sp + 56], %r_old_sp;  // 保存返回地址/旧 sp

// 函数出口：恢复栈
ld.local.u64 %r_old_sp, [%sp + 56];
mov.u64 %sp, %r_old_sp;
ret;
```

---

### 架构支持
| 操作 | 最小架构 | 说明 |
|------|--------|------|
| `%sp` 寄存器 | sm_20 | Fermi+ |
| `alloca` | sm_50 | Maxwell+（实际由编译器模拟） |
| `.shared::cluster` alloca | sm_90 | Hopper+ |

---

## 9.7.18 视频指令（Video Instructions）

> NVIDIA GPU 提供专用 **视频解码/后处理硬件单元**（NVENC/NVDEC），PTX 通过特定指令暴露部分功能，主要用于 **视频后处理** 和 **图像格式转换**。

### 通用特性
- **仅支持特定数据类型**：`.u8`, `.u16`, `.b32`
- **向量操作**：通常处理 `.v2`, `.v4` 向量
- **饱和运算**：自动钳位到 `[0, 255]` 或 `[0, 65535]`

---

### 1. `vadd4` — 四通道字节加法（饱和）
```ptx
vadd4.u32 d, a, b;
```
- **功能**：将 `a` 和 `b` 视为 4 个无符号 8 位整数，执行饱和加法
  ```c
  for (i=0; i<4; i++) {
      uint16_t sum = (a>>8*i & 0xFF) + (b>>8*i & 0xFF);
      d |= (min(sum, 255) << 8*i);
  }
  ```
- **用途**：RGBA 图像加法、亮度调整
- **架构**：sm_30+

---

### 2. `vsub4` — 四通道字节减法（饱和）
```ptx
vsub4.u32 d, a, b;
```
- **功能**：4 通道饱和减法（结果 ≥ 0）
- **用途**：图像差分、色度键抠图

---

### 3. `vavrg4` — 四通道字节平均
```ptx
vavrg4.u32 d, a, b;
```
- **功能**：`d[i] = (a[i] + b[i]) / 2`（无舍入误差）
- **用途**：运动估计、图像混合

---

### 4. `vset4` — 四通道字节比较
```ptx
vset4.op.u32 d, a, b;
```
- **操作符**：`.eq`, `.ne`, `.lt`, `.le`, `.gt`, `.ge`
- **功能**：逐通道比较，结果为 0xFF（真）或 0x00（假）
- **示例**：
  ```ptx
  vset4.eq.u32 %r1, %r2, %r3;  // r1 = { (r2[3]==r3[3])?0xFF:0, ... }
  ```

---

### 5. `vmad` / `vmad2` — 视频乘加（Hopper+）
```ptx
vmad.u8.u8.u16 d, a, b, c;  // d = a*b + c （饱和到 u8）
```
- **用途**：色彩空间转换（如 YUV→RGB）
- **架构**：sm_90+

---

### 6. `dp4a` — 点积 4 通道累加（Integer Dot Product）
```ptx
dp4a.s32.s32 d, a, b, c;  // d = c + Σ(a[i]*b[i]) for i=0..3
```
- **功能**：4 个 8 位有符号/无符号整数点积 + 累加
- **用途**：卷积、矩阵乘（INT8 推理）
- **变体**：
  - `dp4a.u32.u32`：无符号
  - `dp4a.s3 s32.s32`：有符号
- **架构**：sm_61+（Pascal+）

---

### 7. `dp2a` — 双通道点积（Volta+）
```ptx
dp2a.u32.u32 d, a, b, c;  // 处理 2 通道
```

---

### 视频指令汇总表

| 指令 | 操作 | 饱和 | 架构 | 典型用途 |
|------|------|------|------|--------|
| `vadd4` | 4×u8 加 | ✅ | sm_30+ | 图像合成 |
| `vsub4` | 4×u8 减 | ✅ | sm_30+ | 运动检测 |
| `vavrg4` | 4×u8 平均 | ❌ | sm_30+ | 图像缩放 |
| `vset4` | 4×u8 比较 | ❌ | sm_30+ | 色键 |
| `dp4a` | 4×int8 点积 | ❌ | sm_61+ | INT8 GEMM |
| `vmad` | u8 乘加 | ✅ | sm_90+ | 色彩转换 |

---

## 9.7.19 杂项指令（Miscellaneous Instructions）

> 包含调试、性能计数、特殊寄存器访问等非核心计算指令。

---

### 1. `trap` — 异常陷阱
```ptx
trap;
```
- **功能**：触发未定义异常，终止 kernel
- **用途**：断言失败、非法状态（见 9.7.12）

---

### 2. `brkpt` — 调试断点
```ptx
brkpt;
```
- **功能**：触发调试器中断（仅调试模式有效）
- **生产代码中应移除**

---

### 3. `clock` / `clock64` — 时钟计数器
```ptx
mov.u32 %r1, %clock;    // 32 位每秒时钟（非 wall-clock）
mov.u64 %rd1, %clock64; // 64 位高精度计数器
```
- **用途**：性能剖析、延迟测量
- **注意**：
  - **非全局同步**：各 SM 时钟独立
  - **非单调**：跨 SM 比较无意义
- **架构**：sm_20+

---

### 4. `pm0`–`pm7` — 性能计数器
```ptx
mov.u32 %r1, %pm0;  // 读取性能计数器 0
```
- **功能**：访问硬件性能监控单元（PMU）
- **用途**：高级性能分析（需特权模式）
- **可用性**：受驱动限制，通常仅限内部工具

---

### 5. `lanemask` — Warp 掩码查询
```ptx
mov.u32 %r1, %lanemask_eq;  // 当前线程 ID 的位掩码
mov.u32 %r1, %lanemask_le;  // ≤ 当前线程 ID 的掩码
mov.u32 %r1, %lanemask_lt;  // < 当前线程 ID 的掩码
mov.u32 %r1, %lanemask_ge;  // ≥ 当前线程 ID 的掩码
mov.u32 %r1, %lanemask_gt;  // > 当前线程 ID 的掩码
```
- **用途**：高效实现 warp-level 扫描（scan）、投票
- **架构**：sm_30+

---

### 6. `tid`, `ntid`, `ctaid`, `nctaid` — 线程/块 ID
```ptx
mov.u32 %r1, %tid.x;     // 线程在 CTA 中的 x 坐标
mov.u32 %r2, %ntid.x;    // CTA 的 x 维度大小
mov.u32 %r3, %ctaid.x;   // CTA 在网格中的 x 坐标
mov.u32 %r4, %nctaid.x;  // 网格的 x 维度大小
```
- **维度**：`.x`, `.y`, `.z`
- **用途**：索引计算、边界检查

---

### 7. `gridid` — 网格 ID
```ptx
mov.u32 %r1, %gridid;
```
- **功能**：返回当前 kernel 网格的唯一 ID
- **架构**：sm_30+

---

### 8. `red` — 规约（已弃用）
> 使用 `atom.shared.red` 或 warp shuffle 替代。

---

### 9. `nanosleep` — 纳秒级休眠
```ptx
nanosleep.u32 %r1;
```
- **功能**：休眠约 `%r1` 个周期（非精确纳秒）
- **用途**：忙等待退避（避免过度占用 SM）
- **架构**：sm_80+

---

## 杂项指令汇总表

| 指令/寄存器 | 功能 | 架构 | 用途 |
|------------|------|------|------|
| `%clock` / `%clock64` | 时钟计数 | sm_20+ | 性能测量 |
| `%lanemask_*` | Warp 掩码 | sm_30+ | Warp 算法 |
| `%tid` / `%ctaid` | 线程/块 ID | all | 索引计算 |
| `%gridid` | 网格 ID | sm_30+ | 多网格区分 |
| `nanosleep` | 休眠 | sm_80+ | 忙等待退避 |
| `%pm0`–`%pm7` | 性能计数器 | sm_20+ | 高级剖析 |
| `trap` / `brkpt` | 异常/断点 | all | 调试 |

---

> ✅ **最佳实践**：
> - 使用 `%lanemask` 实现高效 warp 扫描
> - 用 `dp4a` 加速 INT8 推理
> - 避免在生产代码中使用 `brkpt`
> - `clock64` 仅用于单 SM 内相对时间测量
> - 栈操作优先依赖编译器（如 `alloca`），而非手动管理 `%sp`

> 📚 **参考**：PTX ISA 9.1, Sections 9.7.17–9.7.19