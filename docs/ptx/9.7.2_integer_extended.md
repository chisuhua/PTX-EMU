
# PTX 指令语法参考文档（PTX ISA 9.1）  
## 9.7.2 扩展精度整数算术指令（Extended-Precision Integer Arithmetic Instructions）

> 章节对照：https://docs.nvidia.com/cuda/parallel-thread-execution/index.html  
> 说明：本文件聚焦**进位链规则**与**指令清单**，细节以官方文档为准。

## 快速索引（本节覆盖指令）
- 带进位输出：`add.cc`, `sub.cc`, `mad.cc`
- 带进位输入：`addc`, `subc`, `madc`（可选 `.cc` 继续链式传播）

---

### 设计原理

GPU 的通用寄存器为 32 位或 64 位，但密码学、大数运算等场景常需处理远超 64 位的整数（如 256 位、512 位）。PTX 通过以下机制支持扩展精度：

- **条件码寄存器（CC）中的进位标志（Carry Flag, CF）**：由 `.cc` 后缀指令生成，隐式传递给后续带进位输入的指令。
- **指令配对与链式扩展**：
  - `add.cc` / `sub.cc` / `mad.cc`：执行基础运算并 **设置进位/借位**
  - `addc` / `subc` / `madc`：执行 **带进位/借位输入** 的运算（自动使用前一条指令产生的 CF）
  - 这些指令还可 **再次带 `.cc` 后缀**（如 `addc.cc`），以在链中 **同时使用并更新进位**
- **无显式进位寄存器**：进位状态由硬件在 CC 寄存器中维护，程序员不可直接访问。

> ⚠️ **重要限制**：
> - **进位链必须连续且无干扰**：`.cc` 指令后必须紧跟使用 CF 的指令（如 `addc`），中间不能插入任何可能修改 CC.CF 的其他指令（包括其他 `.cc` 指令）。
> - **不支持跨函数调用保留进位**：CC.CF 在函数调用时不被保存，扩展精度运算必须在单个函数内完成。
> - **谓词执行需 warp-uniform**：若 `.cc` 指令使用谓词（`@p`），则所有线程必须统一执行或跳过该指令；否则会导致 warp 内进位状态不一致，行为未定义。
> - **操作数类型**：语法上支持 `.u32`, `.s32`, `.u64`, `.s64`；但进位/借位语义仅依赖位级加法，因此通常用于无符号多精度整数（推荐使用 `.u32` 或 `.u64`）。

---

## 一、加法指令

### 1. `add.cc` — 带进位输出的加法
```ptx
add.cc.type d, a, b;
```
- **功能**：计算 `sum = a + b`，将结果低 N 位写入 `d`，并将 **进位（carry-out）** 写入 CC.CF。
- **支持类型**：`.u32`, `.s32`, `.u64`, `.s64`
- **行为**（以无符号为例）：
  ```c
  uint64_t sum = (uint64_t)a + b;
  d = (type == .u32) ? (uint32_t)sum : sum;
  CC.CF = (sum >> width(type)) & 1;
  ```
- **示例（64+64 → 128 位加法）**：
  ```ptx
  add.cc.u64 %rd_lo, %A_lo, %B_lo;  // 低 64 位加，生成进位
  addc.u64   %rd_hi, %A_hi, %B_hi;  // 高 64 位加 + 进位
  ```

### 2. `addc` — 带进位输入的加法
```ptx
addc{.cc}.type d, a, b;
```
- **功能**：计算 `d = a + b + CC.CF`。
- 若指定了 `.cc` 后缀，则 **同时将新的进位写回 CC.CF**，支持长链扩展。
- **支持类型**：同 `add.cc`
- **关键特性**：
  - `addc` 可单独使用（不输出进位），也可写作 `addc.cc`（输出进位）。
  - 是构建 **任意长度加法链** 的核心指令。

- **多段加法示例（128+128 → 256 位）**：
  ```ptx
  add.cc.u64  %r0, %A0, %B0;   // 最低位，生成进位
  addc.cc.u64 %r1, %A1, %B1;   // 中间位，用进位 + 生成新进位
  addc.cc.u64 %r2, %A2, %B2;   // ...
  addc.u64    %r3, %A3, %B3;   // 最高位，仅使用进位（不再输出）
  // 若需 257 位结果，可再执行: addc.u64 %r4, 0, 0;
  ```

---

## 二、减法指令

### 3. `sub.cc` — 带借位输出的减法
```ptx
sub.cc.type d, a, b;
```
- **功能**：计算 `diff = a - b`，将结果低 N 位写入 `d`，并将 **借位（borrow-out）** 写入 CC.CF（若 `a < b`，则 borrow = 1）。
- **支持类型**：`.u32`, `.s32`, `.u64`, `.s64`
- **行为**：
  ```c
  uint64_t diff = (uint64_t)a - b;
  d = (type == .u32) ? (uint32_t)diff : diff;
  CC.CF = (a < b) ? 1 : 0;  // 借位 = 1 表示需要从高位借
  ```
- **示例（128 位减法）**：
  ```ptx
  sub.cc.u64 %rd_lo, %A_lo, %B_lo;  // 低 64 位减，生成借位
  subc.u64   %rd_hi, %A_hi, %B_hi;  // 高 64 位减 - 借位
  ```

### 4. `subc` — 带借位输入的减法
```ptx
subc{.cc}.type d, a, b;
```
- **功能**：计算 `d = a - b - CC.CF`。
- 若指定 `.cc`，则将新的借位写回 CC.CF。
- **支持类型**：同 `sub.cc`
- **用途**：多段减法链（类似 `addc`）

---

## 三、融合乘加指令（Extended-Precision MAD）

### 5. `mad.cc` — 带进位输出的融合乘加
```ptx
mad.cc.type d, a, b, c;
```
- **功能**：计算 `result = a * b + c`，将 **低 32 位** 写入 `d`，**高 32 位** 作为进位写入 CC.CF。
- **支持类型**：仅 `.u32`, `.s32`（**不支持 64 位**）
- **行为**：
  ```c
  uint64_t prod = (uint64_t)a * b + c;
  d = (uint32_t)prod;
  CC.CF = prod >> 32;
  ```
- **用途**：高效实现多精度乘法中的部分积累加（如 Montgomery 乘法）

### 6. `madc` — 带进位输入的融合乘加
```ptx
madc{.cc}.type d, a, b, c;
```
- **功能**：计算 `d = a * b + c + CC.CF`。
- 若指定 `.cc`，则将新的进位写回 CC.CF。
- **支持类型**：仅 `.u32`, `.s32`
- **典型用法（多精度乘法累加）**：
  ```ptx
  // R[0..3] += A[i] * B[j]
  mad.cc.u32  %t0, %A_i, %B_j, %R0;
  madc.cc.u32 %t1, 0, 0, %R1;   // 传播进位（a=b=0）
  madc.cc.u32 %t2, 0, 0, %R2;
  madc.u32    %t3, 0, 0, %R3;   // 最后一段不输出进位
  mov.u32 %R0, %t0;
  mov.u32 %R1, %t1;
  mov.u32 %R2, %t2;
  mov.u32 %R3, %t3;
  ```

> 💡 **技巧**：`madc.u32 d, 0, 0, c;` 等价于 `addc.u32 d, c, 0;`，可用于纯进位传播。

---

## 四、指令组合与进位链规则

### 有效进位链模式

| 场景 | 指令序列 |
|------|--------|
| 多精度加法 | `add.cc → (addc.cc)* → addc` |
| 多精度减法 | `sub.cc → (subc.cc)* → subc` |
| 多精度乘加 | `mad.cc → (madc.cc)* → madc` |

> 注：`*` 表示零次或多次重复；链中除首尾外，中间段应使用 `.cc` 后缀以传递进位。

### 无效/危险模式（应避免）

- 在 `.cc` 和后续 `c` 指令之间插入其他修改 CC.CF 的指令（如 `setp`, `slct`, 其他 `.cc` 指令等）
- 使用 divergent 谓词（warp 内部分线程执行 `.cc`，部分不执行）
- 混合加法与减法链（如 `add.cc → subc`）
- 跨函数调用延续进位链

---

## 五、架构支持

| 指令 | sm_20+ | sm_35+ | sm_50+ | sm_70+ | sm_90+ |
|------|--------|--------|--------|--------|--------|
| `add.cc.u32` / `addc.u32` | ✅ | ✅ | ✅ | ✅ | ✅ |
| `add.cc.u64` / `addc.u64` | ✅ | ✅ | ✅ | ✅ | ✅ |
| `sub.cc.u32` / `subc.u32` | ✅ | ✅ | ✅ | ✅ | ✅ |
| `sub.cc.u64` / `subc.u64` | ✅ | ✅ | ✅ | ✅ | ✅ |
| `mad.cc.u32` / `madc.u32` | ✅ | ✅ | ✅ | ✅ | ✅ |

> **说明**：
> - 32 位扩展精度指令自 PTX ISA 1.0 起即支持（对应 sm_10+）。
> - 64 位扩展精度指令自 PTX ISA 1.2 起支持（对应 sm_20+）。
> - 所有现代架构（sm_35 及以上）均完整支持上述指令。

---

## 六、典型应用

### 示例 1：128 位无符号整数加法
```ptx
.reg .u64 %A<2>, %B<2>, %R<2>;

add.cc.u64 %R0, %A0, %B0;  // 低 64 位
addc.u64   %R1, %A1, %B1;  // 高 64 位 + 进位
// 最终进位保留在 CC.CF（若需 192 位结果，可继续 addc.u64 %R2, 0, 0;）
```

### 示例 2：256 位加法（四段）
```ptx
add.cc.u64  %R0, %A0, %B0;
addc.cc.u64 %R1, %A1, %B1;
addc.cc.u64 %R2, %A2, %B2;
addc.u64    %R3, %A3, %B3;
```

### 示例 3：多精度乘积累加（Montgomery 风格）
```ptx
mad.cc.u32  %t0, %a, %b, %acc0;
madc.cc.u32 %t1, 0, 0, %acc1;
madc.u32    %t2, 0, 0, %acc2;
mov.u32 %acc0, %t0;
mov.u32 %acc1, %t1;
mov.u32 %acc2, %t2;
```

---

## 七、总结表

| 指令 | 操作数数量 | 支持类型 | 功能 | 进位行为 |
|------|------------|----------|------|--------|
| `add.cc` | 2 | `.u32`, `.s32`, `.u64`, `.s64` | `d = a + b` | 输出进位到 CC.CF |
| `addc` / `addc.cc` | 2 | 同上 | `d = a + b + CF_in` | `.cc` 版本输出新进位 |
| `sub.cc` | 2 | `.u32`, `.s32`, `.u64`, `.s64` | `d = a - b` | 输出借位（CF = 1 if a < b） |
| `subc` / `subc.cc` | 2 | 同上 | `d = a - b - CF_in` | `.cc` 版本输出新借位 |
| `mad.cc` | 3 | `.u32`, `.s32` | `d = a*b + c`（低32位） | 输出高32位作为进位 |
| `madc` / `madc.cc` | 3 | `.u32`, `.s32` | `d = a*b + c + CF_in` | `.cc` 版本输出新进位 |

---

## ✅ 最佳实践

- **优先使用 `.u32` 构建任意宽度整数**：兼容性最好，所有架构均支持。
- **长链运算务必使用 `addc.cc` / `subc.cc` / `madc.cc`**：确保进位正确传递。
- **避免在进位链中插入无关指令**：包括内存操作、分支、其他算术指令。
- **在密码学、大数库（如 cuBLAS、cuRAND、OpenSSL-GPU）中广泛使用**。

> 📚 **官方参考**：  
> NVIDIA PTX ISA 9.1, Section 9.7.2 “Extended-Precision Integer Arithmetic Instructions”  
> https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#extended-precision-integer-arithmetic-instructions
