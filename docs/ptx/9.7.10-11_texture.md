
# 9.7.10–9.7.11 纹理与表面指令（Texture and Surface Instructions）

> 章节对照：https://docs.nvidia.com/cuda/parallel-thread-execution/index.html  
> 说明：本文件提供**指令清单 + 关键约束**，完整语义以官方文档为准。

## 快速索引（本节覆盖指令）
- 纹理采样：`tex`, `tex.ldg`, `tex.grad`, `tex.lod`
- 纹理查询：`txq.*`
- 表面读写：`suld`, `sust`
- 表面查询：`suq.*`

---

## 一、通用概念

### 1. 地址空间与访问模型
| 类型 | 访问权限 | 指令前缀 | 底层绑定方式 |
|------|--------|--------|------------|
| **纹理（Texture）** | 只读 | `tex.*`, `txq.*` | 通过 `cudaCreateTextureObject` 或传统 `texref` 绑定到 `cudaArray` 或线性内存 |
| **表面（Surface）** | 读写 | `suld.*`, `sust.*`, `suq.*` | 通过 `cudaCreateSurfaceObject` 绑定到 `cudaArray` 或线性内存 |

> ⚠️ 注意：PTX 层不直接管理资源绑定，仅通过 `.texref` / `.surfref` 符号或 `.u64` 寄存器（间接访问）引用已由主机端绑定的对象。

### 2. 数据布局支持
- **维度**：1D、2D、3D
- **层叠（Layered）**：
  - `.a1d`：1D 层叠（即纹理数组）
  - `.a2d`：2D 层叠
- **存储类型**：
  - `cudaArray`（默认，支持压缩、mipmap）
  - **线性内存**（sm_35+ 支持，需显式声明为可纹理化）

### 3. 数据类型与归一化
- **支持类型**：
  - 整数：`.s8`, `.u8`, `.s16`, `.u16`, `.s32`, `.u32`
  - 浮点：`.f16`（sm_60+）, `.f32`
- **归一化行为**：
  - 若纹理对象声明为“归一化”（`normalizedCoords = true`），整数通道自动映射至 `[0,1]`（无符号）或 `[-1,1]`（有符号）
  - 归一化由 **CUDA 对象配置决定**，非 PTX 指令控制

---

## 二、9.7.10 纹理指令（Texture Instructions）

> 所有纹理指令为 **只读**，支持硬件插值、mipmap 选择、各向异性滤波及多种寻址模式（由 CUDA 对象配置）。

### 1. 基础采样：`tex`

```ptx
tex.2d.v4.f32.f32 {%f0,%f1,%f2,%f3}, [tex_img], {%f4,%f5};
```

#### 语法
```ptx
tex.{geom}.{vec}.type.{coord_type} d, [texref], coord;
```

- **`geom`（几何）**：
  - `.1d`, `.2d`, `.3d`
  - `.a1d`（1D array）, `.a2d`（2D array）
- **`vec`（向量）**：`.v2`, `.v4`（默认标量）
- **`type`（返回类型）**：`.f32`, `.f16`, `.u32`, `.s32`, `.u16`, `.s16`, `.u8`, `.s8`
- **`coord_type`（坐标类型）**：`.f32`（插值）, `.s32`（最近邻）

#### 坐标格式（寄存器数量）
| 几何 | `.f32` 坐标 | `.s32` 坐标 |
|------|-----------|-----------|
| `.1d` | 1 (`x`) | 1 (`x`) |
| `.2d` | 2 (`x, y`) | 2 (`x, y`) |
| `.3d` | 3 (`x, y, z`) | 3 (`x, y, z`) |
| `.a1d` | 2 (`x, layer`) | 2 (`x, layer`) |
| `.a2d` | 3 (`x, y, layer`) | 3 (`x, y, layer`) |

> 📌 注意：对于 `.a1d`/`.a2d`，**第一坐标是 layer 索引**（整数），第二/第三是空间坐标。

#### 行为语义
- **浮点坐标（`.f32`）**：
  - 启用双线性/三线性插值（若对象启用）
  - 支持归一化 `[0,1]` 或非归一化（像素单位）坐标（由对象配置）
- **整数坐标（`.s32`）**：
  - 最近邻采样（无插值）
  - 坐标作为数组索引（从 0 开始）

---

### 2. 缓存提示变体：`tex.ldg`

```ptx
tex.ldg.2d.f32.f32 %f0, [tex_in], {%fx,%fy};
```

- **功能**：与 `tex` 语义相同，但向缓存系统提示“一次性访问”（streaming hint）
- **状态**：**未弃用**，在 sm_60+ 架构中可能与 `tex` 行为一致，但仍为合法指令
- **用途**：优化大纹理遍历的缓存污染

---

### 3. 显式梯度控制：`tex.grad`

```ptx
tex.grad.2d.v4.f32.f32 d, [texref], coord, dPdx, dPdy;
```

- **用途**：手动提供偏导，用于各向异性滤波（如光线追踪）
- **坐标与梯度寄存器数**（以 `.2d` 为例）：
  - `coord`: 2（`x, y`）
  - `dPdx`: 2（`∂x/∂u, ∂y/∂u`）
  - `dPdy`: 2（`∂x/∂v, ∂y/∂v`）
- **限制**：不支持 `.2dms` / `.a2dms`（多采样纹理）

---

### 4. 显式 LOD 控制：`tex.lod`

```ptx
tex.lod.2d.f32.f32 %f0, [texref], {%fx,%fy}, %lod;
```

- **`lod`**：单个 `.f32` 寄存器，指定 mip-level（0 = 最精细）
- **要求**：纹理对象必须包含 mipmap 链

---

### 5. 投影纹理
- PTX **无 `tex.ptx` 指令**
- 投影除法（`x/w, y/w`）需在 PTX 中手动实现

---

### 6. 纹理查询：`txq`

```ptx
txq.width.b32 %r1, [texref];
txq.array_size.b32 %r2, [texref];
txq.num_mip_levels.b32 %r3, [texref];
txq.channel_data_type.b32 %r4, [texref];
txq.channel_order.b32 %r5, [texref];
```

| 查询字段 | 返回值含义 |
|--------|----------|
| `.width` | 第 0 层宽度 |
| `.height` | 第 0 层高度（2D/3D） |
| `.depth` | 深度（3D） |
| `.array_size` | 层数（array） |
| `.num_mip_levels` | mipmap 层数 |
| `.channel_data_type` | 数据类型编码（如 `CU_AD_FORMAT_FLOAT`） |
| `.channel_order` | 通道顺序（如 `CU_AD_FORMAT_RGBA`） |

> 💡 主要用于 OpenCL 互操作或运行时自适应 kernel

---

## 三、9.7.11 表面指令（Surface Instructions）

> 表面内存支持 **读写**，但 **不支持插值、LOD、滤波或复杂寻址模式**。所有访问为最近邻，边界行为由指令后缀控制。

### 1. 表面加载：`suld`

```ptx
suld.2d.v4.f32.trap {%f0,%f1,%f2,%f3}, [surf_out], {%r1,%r2};
```

#### 语法
```ptx
suld.{geom}.{vec}.type.{boundary} d, [surfref], coord;
```

- **`geom`**：`.1d`, `.2d`, `.3d`, `.a1d`, `.a2d`
- **`boundary`**：
  - `.trap`（默认）：越界时触发 trap（kernel 失败）
  - `.clamp`：坐标钳位至 `[0, width)` 等有效范围
- **坐标**：必须为 `.s32` 整数，格式同纹理整数坐标

---

### 2. 表面存储：`sust`

```ptx
sust.2d.v4.f32.clamp [surf_out], {%r1,%r2}, {%f0,%f1,%f2,%f3};
```

#### 语法
```ptx
sust.{geom}.{vec}.type.{boundary} [surfref], coord, value;
```

- **`value`**：寄存器组（标量/向量）
- **其他字段**：同 `suld`

---

### 3. 表面查询：`suq`

```ptx
suq.width.b32 %r1, [surf_A];
suq.array_size.b32 %r2, [surf_B];
suq.memory_layout.b32 %r3, [surf_C]; // 1 = linear, 0 = cudaArray
suq.channel_data_type.b32 %r4, [surf_D];
suq.channel_order.b32 %r5, [surf_E];
```

| 查询字段 | 说明 |
|--------|------|
| `.width`, `.height`, `.depth` | 尺寸 |
| `.array_size` | 层数 |
| `.memory_layout` | 1 = 线性内存，0 = cudaArray |
| `.channel_data_type`, `.channel_order` | 同 `txq` |

> ⚠️ `suq` 是 PTX 9.7.11.4 明确定义的指令，常用于动态适配表面属性

---

### 4. 表面原子操作
- **PTX ISA 9.1 未定义原生表面原子指令**（如 `sust.atom.add`）
- 若需原子操作：
  - 方案 1：使用全局内存原子指令（将数据存于普通全局内存）
  - 方案 2：通过 CUDA C++ 的 `surf1Dwrite(..., cudaSurfaceBoundaryModeTrap)` + 原子函数（底层仍转为全局原子）
- **结论**：PTX 层无表面原子支持，需绕行

---

## 四、架构支持与限制

| 特性 | 最小架构 | 说明 |
|------|--------|------|
| `tex.*` / `suld` / `sust`（基础） | sm_20 | Fermi+ |
| 层叠纹理/表面（`.a1d`, `.a2d`） | sm_30 | Kepler+ |
| 线性内存作为纹理/表面 | sm_35 | Kepler+（需 `cudaMalloc` + `cudaBindTexture` 或 `cudaCreateTextureObject`） |
| `.f16` 纹理/表面 | sm_60 | Pascal+ |
| 间接访问（`[reg]`） | sm_20 | 允许 `[a]` 中 `a` 为 `.u64` 寄存器 |
| `txq` / `suq` 查询 | sm_30 | Kepler+ |

### 关键限制
1. **纹理只读，表面可读写**
2. **表面不支持插值、滤波、LOD**
3. **纹理浮点坐标 → 插值；整数坐标 → 最近邻**
4. **表面坐标必须为整数**
5. **纹理/表面尺寸受硬件限制**（如 2D 最大 16K×16K，3D 最大 2K³）
6. **多采样纹理（`.2dms`）仅支持特定指令子集**

---

## 五、典型应用场景

### 1. 图像双线性插值（纹理只读）
```ptx
tex.2d.v4.f32.f32 {%f0,%f1,%f2,%f3}, [tex_in], {%fx,%fy};
```

### 2. GPGPU 结果写入（表面写入）
```ptx
sust.2d.v4.f32.clamp [surf_out], {%ix,%iy}, {%f0,%f1,%f2,%f3};
```

### 3. 查找表（1D 纹理，整数索引）
```ptx
tex.1d.f32.s32 %f0, [tex_lut], %r_index;
```

### 4. 体积数据采样（3D 纹理）
```ptx
tex.3d.f32.f32 %f0, [tex_vol], {%fx,%fy,%fz};
 参考：
 - https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#texture-instructions
 - https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#surface-instructions

### 5. 动态适配表面尺寸
```ptx
suq.width.b32 %r_w, [surf_out];
setp.lt.s32 %p, %ix, %r_w;
@%p sust.1d.f32.trap [surf_out], {%ix}, {%f0};
```

---

## 六、总结对比表

| 特性 | 纹理（`tex.*`） | 表面（`suld`/`sust`） |
|------|----------------|---------------------|
| **读写** | 只读 | 读写 |
| **插值** | ✅（浮点坐标） | ❌ |
| **LOD/mipmap** | ✅ | ❌ |
| **坐标类型** | 浮点 / 整数 | 整数 only |
| **边界处理** | 由 CUDA 对象配置（wrap/clamp/mirror） | 由指令后缀指定（`.trap` / `.clamp`） |
| **查询指令** | `txq.*` | `suq.*` |
| **典型用途** | 输入纹理、LUT、体积数据 | 输出缓冲区、中间结果、GPGPU 写回 |

---

## ✅ 最佳实践建议

- **优先使用纹理对象（texture object）和表面对象（surface object）**，而非传统引用（更灵活、支持间接访问）
- **对只读大数组使用纹理**：利用 L1/L2 缓存和插值硬件
- **对需写入的结果使用表面**：避免全局内存散写性能瓶颈
- **调试阶段使用 `.trap` 边界模式**，生产部署可切换为 `.clamp`
- **避免在 kernel 中频繁绑定/解绑资源**：绑定应在主机端一次性完成

---

参考：
- https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#texture-instructions
- https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#surface-instructions

--- 

如需严格语义与边界条件，请以官方文档为准。