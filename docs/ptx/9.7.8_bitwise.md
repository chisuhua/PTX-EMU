
# PTX 指令语法参考文档（基于 PTX ISA 9.1）  
## 9.7.8 逻辑与移位指令（Logic and Shift Instructions）详解

> 本节依据 [NVIDIA 官方 PTX 文档](https://docs.nvidia.com/cuda/parallel-thread-execution/index.html)（PTX ISA 9.1），系统阐述 **逻辑运算** 与 **移位操作** 指令的完整语法、操作数约束、支持的数据类型、行为语义及典型应用场景。这些指令是位级编程、掩码生成、数据打包/解包、密码学和向量化处理的核心工具。

---

## 通用规则

### 数据类型
- 所有逻辑与移位指令使用 **位类型（bitwise types）**：
  - `.b8`, `.b16`, `.b32`, `.b64`
- 这些类型将操作数视为 **无符号整数位串**，不区分有符号/无符号语义。
- 寄存器宽度必须匹配：`.b32` 操作 32 位寄存器，`.b64` 操作 64 位寄存器。
- **例外**：`cnot` 虽使用 `.b32` 等类型，但其语义基于整数值是否为零，而非位模式。

### 立即数支持
- 多数指令的源操作数可为 **立即数（immediate）**，但受架构限制：
  - 32 位立即数通常需在编译时确定
  - 移位类指令（如 `shl`, `shr`）的移位量可为寄存器或常量（范围见各指令说明）

---

## 一、基本逻辑运算

### 1. `and` — 按位与
```ptx
and.b32 d, a, b;
```
- **功能**：`d = a & b`
- **支持类型**：`.b8`, `.b16`, `.b32`, `.b64`
- **用途**：掩码提取、标志检查
- **示例**：
  ```ptx
  and.b32 %r1, %r2, 0xFFFF0000;  // 提取高 16 位
  ```

### 2. `or` — 按位或
```ptx
or.b32 d, a, b;
```
- **功能**：`d = a | b`
- **用途**：标志设置、位域合并

### 3. `xor` — 按位异或
```ptx
xor.b32 d, a, b;
```
- **功能**：`d = a ^ b`
- **用途**：奇偶校验、无临时变量交换、加密算法

### 4. `not` — 按位非
```ptx
not.b32 d, a;
```
- **功能**：`d = ~a`（对整个寄存器逐位取反）
- **注意**：高位也被取反，结果依赖于操作数位宽

### 5. `cnot` — 条件非（Conditional NOT，C 风格逻辑非）
```ptx
cnot.b32 d, a;
```
- **功能**：`d = (a == 0) ? 1 : 0`
- **输入**：`a` 是整数寄存器（如 `.b32`），**不是谓词寄存器**
- **输出**：标准化布尔值（0 或 1）
- **用途**：实现 C/C++ 中的 `!a`，将任意整数转换为逻辑 0/1
- **常见误区**：
  - ❌ 错误：`cnot.b32 d, %p;`（若 `%p` 是 `.pred` 类型，非法）
  - ✅ 正确：对整数使用；谓词取反应使用 `not.pred p1, p2`

---

## 二、三操作数通用逻辑：`lop3`

### 6. `lop3` — 三输入通用逻辑函数（LUT-based）
```ptx
lop3.LUT.b32 d, a, b, c, imm8;
```
- **功能**：执行任意 3 输入布尔函数，由 8 位 **真值表（LUT）** 定义
- **公式**（对每一位 `i`）：
  ```
  index = (a[i] << 2) | (b[i] << 1) | c[i]   // ∈ [0,7]
  d[i] = (imm8 >> index) & 1
  ```
- **支持类型**：仅 `.b32`
- **LUT 编码示例**：
  | 逻辑表达式            | LUT (hex) | 二进制（MSB→LSB: 7→0） |
  |----------------------|----------|------------------------|
  | `a & b & c`          | `0x80`   | `1000 0000`            |
  | `a \| b \| c`        | `0xFE`   | `1111 1110`            |
  | `a ^ b ^ c`          | `0x96`   | `1001 0110`            |
  | `a ? b : c`（mux）   | `0xCA`   | `1100 1010`            |
  | `~a`                 | `0x55`   | `0101 0101`（忽略 b,c）|

- **优势**：单指令实现复杂组合逻辑，减少指令发射和延迟
- **示例**（三元选择）：
  ```ptx
  lop3.LUT.b32 %d, %a, %b, %c, 0xCA;  // %d = %a ? %b : %c
  ```

> 💡 **提示**：现代 CUDA 编译器（NVCC）在 `-O3` 下会自动将合适代码映射到 `lop3`。手动使用可进一步压榨性能。

---

## 三、移位操作

### 7. `shl` — 逻辑左移（Shift Left Logical）
```ptx
shl.b32 d, a, b;
```
- **功能**：`d = a << b`，低位补 0，高位丢弃
- **移位量 `b`**：
  - 可为寄存器或立即数
  - 有效范围：0 ≤ `b` < 位宽（`.b32` → 0–31；`.b64` → 0–63）
  - 若 `b ≥ 位宽`，结果为 0
- **支持类型**：`.b8`, `.b16`, `.b32`, `.b64`

### 8. `shr` — 逻辑右移（Shift Right Logical）
```ptx
shr.b32 d, a, b;
```
- **功能**：`d = a >> b`，高位补 0，低位丢弃
- **关键点**：
  - **始终是逻辑右移**，即使操作数代表有符号整数
  - **PTX 不提供原生算术右移指令**
- **模拟算术右移（32 位）**：
  ```ptx
  shr.b32 %t1, %x, %n;                // 逻辑右移
  and.b32 %sign, %x, 0x80000000;      // 提取符号位
  sub.b32 %shift, 31, %n;             // 31 - n
  shl.b32 %sign_ext, %sign, %shift;   // 符号扩展
  or.b32 %result, %t1, %sign_ext;     // 合并
  ```

### 9. `shf` — 双寄存器 funnel 移位（Shift with Fill）
```ptx
shf.{left|right}.{wrap|clamp}.b32 d, a, b, c;
```
- **引入版本**：PTX ISA 3.0+
- **功能**：从 64 位值 `a:b`（`a`=高32位, `b`=低32位）中提取连续 32 位窗口
- **方向语义**：
  - `.left`：从 LSB 向 MSB 提取（等价于 **funnel shift right**）
  - `.right`：从 MSB 向 LSB 提取（等价于 **funnel shift left**）
- **边界处理**：
  - `.clamp`：超出 `a:b` 范围的位补 0
  - `.wrap`：循环移位（超出部分从另一端补入）
- **移位量 `c`**：0 ≤ `c` ≤ 63（6 位值，可为寄存器或立即数）
- **数学定义（`.left.clamp`）**：
  ```c
  uint64_t ab = ((uint64_t)a << 32) | b;
  d = (c <= 63) ? (ab >> c) : 0;
  ```
- **典型用途**：
  - 64 位整数移位（高效替代多条 `shl`/`shr`/`or`）
  - 位流解析（如视频编码、哈希）
  - 大整数算术
- **示例**（64 位左移 5 位，取低 32 位）：
  ```ptx
  shf.left.clamp.b32 %r_low, %r_hi, %r_lo, 5;
  ```

---

## 四、指令组合与典型应用

### 1. 位域提取（替代 `bfe`）
```ptx
shr.b32 %t1, %r1, 8;     // 右移 8 位
and.b32 %r2, %t1, 0xF;   // 掩码取低 4 位 → 提取 bits [11:8]
```

### 2. 循环左移（Rotate Left, 32 位）
```ptx
// rotl(x, n) = (x << n) | (x >> (32 - n))
shl.b32 %t1, %x, %n;
sub.b32 %t2, 32, %n;
shr.b32 %t2, %x, %t2;
or.b32 %result, %t1, %t2;
```

### 3. 使用 `lop3` 实现三元选择
```ptx
lop3.LUT.b32 %d, %cond, %true_val, %false_val, 0xCA;  // LUT = 11001010
```

### 4. 64 位逻辑左移（{hi, lo} <<= n, n < 32）
```ptx
shl.b32 %lo_new, %lo, %n;
shr.b32 %carry, %lo, sub(32, %n);
or.b32 %hi_new, %hi, %carry;
shl.b32 %hi_new, %hi_new, %n;
```
> 更高效方式（使用 `shf`）：
> ```ptx
> shf.left.clamp.b32 %lo_new, %hi, %lo, %n;
> shf.left.clamp.b32 %hi_new, 0, %hi, %n;
> ```

---

## 总结表：逻辑与移位指令

| 指令 | 操作数 | 类型 | 功能 | 关键特性 |
|------|--------|------|------|----------|
| `and` / `or` / `xor` | 2 | `.b8/.b16/.b32/.b64` | 基础按位运算 | 支持立即数 |
| `not` | 1 | 同上 | 按位取反 | — |
| `cnot` | 1（整数） | `.b32`（常用） | `(a==0)?1:0` | **非谓词操作** |
| `lop3` | 3 + imm8 | `.b32` | 任意 3 输入逻辑 | 单指令复杂逻辑 |
| `shl` / `shr` | 2 | `.b8/.b16/.b32/.b64` | 逻辑左/右移 | 移位量 0–31/63；超限得 0 |
| `shf` | 3 | `.b32` | 双寄存器 funnel shift | `{left/right}.{wrap/clamp}`；移位量 0–63 |

---

## ✅ 最佳实践

- **优先使用 `shf`** 替代多条移位+或操作，提升大整数/位流处理效率。
- **在位操作密集型内核**（如 SHA、AES、CRC）中，考虑手动使用 `lop3` 减少指令数。
- **避免混淆 `cnot` 与谓词操作**：`cnot` 作用于整数，谓词取反用 `not.pred`。
- **PTX 无算术右移**：如有需要，必须显式实现符号扩展。
- **移位量安全**：确保 `shl`/`shr` 的移位量在合法范围内，否则结果为 0。

---

> 📚 **官方参考**：  
> NVIDIA, *PTX: Parallel Thread Execution ISA Version 9.1*, Section 9.7.8 “Logic and Shift Instructions”  
> URL: https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#logic-and-shift-instructions

--- 

此文档已全面校对，可直接用于工程参考或教学材料。如需 PDF 或 LaTeX 版本，也可告知。