# PTX 指令语法参考文档（PTX ISA 9.1）  
## 9.7.6–9.7.7 比较与选择指令

> 章节对照：https://docs.nvidia.com/cuda/parallel-thread-execution/index.html  
> 说明：本文件提供**指令清单 + 选择/谓词规则要点**，完整语义以官方文档为准。

## 快速索引（本节覆盖指令）
- 比较：`set`, `setp`
- 选择：`selp`, `slct`
- 半精度比较：`set`/`setp` 的 `.f16` 与 `.f16x2` 变体

---

## 通用规则

### 比较结果表示
- **`set` / `setp`**：执行二元比较（如 `a OP b`），结果为布尔值。
  - `set`：结果写入 **无符号整数寄存器**（值为 0 或 1）
  - `setp`：结果写入 **谓词寄存器**（`p0`–`p7`），用于后续谓词执行（`@p instr`）
- **`selp` / `slct`**：基于条件选择值，避免显式分支。

### 支持的数据类型
| 类型族 | 具体类型 | 说明 |
|--------|--------|------|
| 整数 | `.s8`, `.u8`, `.s16`, `.u16`, `.s32`, `.u32`, `.s64`, `.u64` | 区分有/无符号比较 |
| 浮点 | `.f16`, `.f16x2`, `.f32`, `.f64` | 遵循 IEEE 754 标准 |
| 位模式 | `.b16`, `.b32`, `.b64` | **仅支持 `.eq` / `.ne`**；按无符号整数解释位模式 |

> ⚠️ **注意**：
> - 浮点比较遵循 IEEE 754（包括对 `NaN` 的处理：任何与 `NaN` 的比较（除 `.ne` 外）均为假）。
> - 整数比较必须明确使用有符号（`.lt` 等）或无符号（`.lo` 等）操作符。

---

## 9.7.6 比较与选择指令（Comparison and Selection Instructions）

### 一、`set` — 比较并返回整数结果

```ptx
set.op.type.dstdtype d, a, b;
```

- **功能**：若 `a OP b` 为真，则 `d = 1`，否则 `d = 0`
- **操作数**：
  - `d`：目标寄存器，**必须为无符号整数类型**（`.u16`, `.u32`, 或 `.u64`）
  - `a`, `b`：源操作数（寄存器或立即数）
- **比较操作符（`op`）**

| 操作符 | 含义 | 适用类型 |
|--------|------|--------|
| `.eq` | equal | 所有类型 |
| `.ne` | not equal | 所有类型 |
| `.lt` | less than | 有符号整数、浮点 |
| `.le` | less or equal | 有符号整数、浮点 |
| `.gt` | greater than | 有符号整数、浮点 |
| `.ge` | greater or equal | 有符号整数、浮点 |
| `.lo` | lower (unsigned <) | 无符号整数、位类型 |
| `.ls` | lower or same (unsigned ≤) | 无符号整数、位类型 |
| `.hi` | higher (unsigned >) | 无符号整数、位类型 |
| `.hs` | higher or same (unsigned ≥) | 无符号整数、位类型 |

> **整数比较关键区别**：
> - 有符号：使用 `.lt`, `.le`, `.gt`, `.ge`
> - 无符号：使用 `.lo`（lower）, `.ls`（lower/same）, `.hi`（higher）, `.hs`（higher/same）
>
> **位类型（`.bXX`）限制**：仅支持 `.eq` 和 `.ne`

- **类型限定符**：
  - `type`：指定 `a` 和 `b` 的解释类型（如 `.s32`, `.f32`）
  - `dstdtype`：指定结果 `d` 的类型（**必须为无符号整数**）

- **示例**：
  ```ptx
  set.eq.u32.u32 %r1, %r2, %r3;     // r1 = (r2 == r3) ? 1 : 0
  set.lt.s32.u32 %r1, %r2, 100;     // r1 = (r2 < 100) ? 1 : 0 （有符号比较）
  set.hi.u32.u32 %r1, %r2, %r3;     // r1 = (r2 > r3) ? 1 : 0 （无符号比较）
  set.eq.b32.u32 %r1, %r2, %r3;     // 位模式相等比较
  ```

---

### 二、`setp` — 比较并返回谓词结果

```ptx
setp.op.type p, a, b;
```

- **功能**：若 `a OP b` 为真，则谓词寄存器 `p` 设为 `true`，否则 `false`
- **结果**：写入谓词寄存器（`p0`–`p7`），用于 `@p instr` 谓词执行
- **支持的操作符和类型**：同 `set`，**但不支持向量类型（如 `.f16x2`）**
- **示例**：
  ```ptx
  setp.ne.f32 p0, %f1, %f2;
  @p0 add.f32 %f3, %f3, 1.0;  // 仅当 f1 != f2 时执行
  ```

> ✅ **优势**：避免分支发散（branch divergence），提升 warp 执行效率。  
> ❌ **限制**：**`setp` 不支持 `.f16x2` 等向量类型**。

---

### 三、`selp` — 谓词选择（Select with Predicate）

```ptx
selp.type d, a, b, p;
```

- **功能**：若谓词 `p` 为真，则 `d = a`，否则 `d = b`
- **操作数**：
  - `d`, `a`, `b`：同类型寄存器（`.s32`, `.f32` 等）
  - `p`：谓词寄存器（`p0`–`p7`）
- **用途**：实现无分支的条件赋值
- **示例**：
  ```ptx
  setp.gt.s32 p0, %r1, 0;
  selp.s32 %r2, %r1, %r3, p0;  // r2 = (r1 > 0) ? r1 : r3
  ```

> 💡 **等价 C 代码**：`d = p ? a : b;`

---

### 四、`slct` — 基于符号的选择（Select by Sign）

```ptx
slct.type d, a, b, c;
```

- **功能**：**检查 `c` 的符号位（最高位）**，而非数值大小：
  - 若符号位 = 0 → `d = a`
  - 若符号位 = 1 → `d = b`
- **关键特性**：
  - **不依赖谓词寄存器**
  - **不执行数值比较**，仅检测 MSB
- **支持类型**：`.s32`, `.s64`, `.f32`, `.f64`
- **IEEE 754 行为（浮点）**：
  - `+0`（符号位 0）→ `d = a`
  - `-0`（符号位 1）→ `d = b`
  - **`NaN` 的行为由其符号位决定**（非未定义）：
    - 正 NaN（如 `0x7FFF`）→ `d = a`
    - 负 NaN（如 `0xFFFF`）→ `d = b`
- **示例**：
  ```ptx
  slct.f32 %f1, %f2, %f3, %f4;  // f1 = (signbit(f4) == 0) ? f2 : f3
  ```

> ⚠️ **注意**：`slct` 是 **单指令** 实现符号判断+选择，比 `setp + selp` 更高效。

---

## 9.7.7 半精度比较指令（Half Precision Comparison Instructions）

> 专为 `.f16` 和 `.f16x2` 设计，语义与 9.7.6 一致，但操作数类型受限。

### 支持的指令
- `set.op.f16` / `set.op.f16x2`
- `setp.op.f16`（**但 `setp.op.f16x2` 非法**）

### 语法规则

#### 单通道（`.f16`）
```ptx
set.eq.f16.u16 %r1, %h1, %h2;
setp.lt.f16 p0, %h1, %h2;
```

#### 双通道（`.f16x2`）
```ptx
set.eq.f16x2.u32 %r1, %h1, %h2;
```
- **行为**：逐通道比较，结果打包为 32 位无符号整数：
  - `%r1[15:0]` = `(h1.low OP h2.low) ? 1 : 0`
  - `%r1[31:16]` = `(h1.high OP h2.high) ? 1 : 0`
- **结果类型**：**必须为 `.u32`**
- **支持的操作符**：`.eq`, `.ne`, `.lt`, `.le`, `.gt`, `.ge`（**无 `.lo`/`.hi`，因是浮点**）

### 重要限制
- ❌ **`setp` 不支持 `.f16x2`**（或任何向量类型）
- ✅ 对 `.f16x2` 的条件判断应使用 `set` + 位运算

### 示例（正确用法）
```ptx
// 比较两个 f16x2 向量
set.eq.f16x2.u32 %r1, %h1, %h2;      // r1 = { high_result, low_result }
and.b32 %r2, %r1, 0x00010001;        // 提取两个通道的布尔结果
set.eq.u32.u32 %r3, %r2, 0x00010001; // r3=1 表示两通道均相等

// 单通道半精度比较（合法）
setp.ne.f16 p0, %h1, %h2;
```

---

## 总结表：比较与选择指令能力

| 指令 | 输出 | 操作数类型 | 关键特性 | 限制 |
|------|------|----------|--------|------|
| `set` | 无符号整数寄存器 | 所有标量类型（整数、浮点、位） | 支持有/无符号比较 | 结果必须为 `.u16`/`.u32`/`.u64` |
| `setp` | 谓词寄存器 | 所有**标量**类型 | 用于谓词执行 | **不支持向量类型（如 `.f16x2`）** |
| `selp` | 数据寄存器 | 所有类型 | 基于谓词选择 | 需先生成谓词 |
| `slct` | 数据寄存器 | `.s32/.s64/.f32/.f64` | 基于符号位选择 | 不进行数值比较 |
| `set.f16` / `setp.f16` | 整数/谓词 | `.f16` | 单通道半精度比较 | — |
| `set.f16x2` | `.u32` 整数 | `.f16x2` | 双通道打包比较结果 | **`setp.f16x2` 非法** |

---

## 典型应用场景

### 1. 无分支最大值
```ptx
setp.gt.s32 p0, %r1, %r2;
selp.s32 %r3, %r1, %r2, p0;  // r3 = max(r1, r2)
```

### 2. 条件累加
```ptx
setp.ne.u32 p0, %mask, 0;
@p0 add.u32 %sum, %sum, %value;
```

### 3. 向量全等判断（半精度）
```ptx
set.eq.f16x2.u32 %r1, %h1, %h2;
set.eq.u32.u32 %r2, %r1, 0x00010001;  // r2=1 当且仅当两通道均相等
```

### 4. 符号函数（signum）
```ptx
slct.s32 %sign, 1, -1, %x;  // 若 x 符号位为 0 返回 1，否则 -1
```

---

> ✅ **最佳实践**：
> - 优先使用 `setp + @p` 替代分支，减少 warp divergence。
> - **避免在向量类型上使用 `setp`**；改用 `set` + 位运算。
> - 利用 `slct` 实现高效的符号判断，避免比较+选择两步操作。
> - 对 `.bXX` 类型，仅使用 `.eq` / `.ne`。

> 📚 **参考**：PTX ISA 9.1, Sections 9.7.6–9.7.7  
> 🔗 [NVIDIA PTX Documentation](https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#comparison-and-selection-instructions)

--- 

如需严格语义与边界条件，请以官方文档为准。