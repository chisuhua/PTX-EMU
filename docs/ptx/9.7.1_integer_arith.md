
# 9.7.1 æ•´æ•°ç®—æœ¯æŒ‡ä»¤ï¼ˆInteger Arithmetic Instructionsï¼‰è¯¦è§£

> æœ¬èŠ‚åŸºäº [NVIDIA PTX ISA 9.1 æ–‡æ¡£](https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#integer-arithmetic-instructions) å¯¹ **æ•´æ•°ç®—æœ¯æŒ‡ä»¤**è¿›è¡Œå®Œæ•´ã€å‡†ç¡®ã€ç»“æ„åŒ–è¯´æ˜ï¼Œæ¶µç›–è¯­æ³•ã€æ“ä½œæ•°çº¦æŸã€æ”¯æŒçš„æ•°æ®ç±»å‹ã€è¡Œä¸ºè¯­ä¹‰ã€ç¡¬ä»¶è¦æ±‚åŠå…¸å‹ç”¨æ³•ã€‚  
> æ‰€æœ‰æŒ‡ä»¤å‡é€‚ç”¨äºé€šç”¨æ•´æ•°è®¡ç®—ï¼›éƒ¨åˆ†æŒ‡ä»¤ï¼ˆå¦‚ `dp4a`ã€`mad24`ï¼‰é’ˆå¯¹ç‰¹å®šæ¶æ„ä¼˜åŒ–æˆ–ç”¨äºå…¼å®¹æ—§ä»£ç ã€‚

---

## é€šç”¨è§„åˆ™

- æ‰€æœ‰æ•´æ•°æŒ‡ä»¤ä½¿ç”¨ **`.type` é™å®šç¬¦**æŒ‡å®šæ“ä½œæ•°çš„ç¬¦å·æ€§ã€ä½å®½æˆ–æ‰“åŒ…æ ¼å¼ã€‚
- **æ”¯æŒçš„åŸºæœ¬æ ‡é‡ç±»å‹**ï¼š
  - `.s8`, `.u8`ï¼ˆä»…ç”¨äºå­˜å‚¨ï¼Œ**ä¸æ”¯æŒç›´æ¥ç®—æœ¯è¿ç®—**ï¼‰
  - `.s16`, `.u16`
  - `.s32`, `.u32`
  - `.s64`, `.u64`
  - `.b32`, `.b64`ï¼ˆç”¨äºä½æ“ä½œï¼Œæ— ç¬¦å·è§£é‡Šï¼‰
- **æ”¯æŒçš„å‘é‡/æ‰“åŒ…ç±»å‹**ï¼ˆPTX ISA 8.0+ï¼Œéœ€ `sm_90+`ï¼‰ï¼š
  - `.s16x2`, `.u16x2`ï¼ˆä¸¤ä¸ª 16 ä½æ•´æ•° packed in 32 ä½å¯„å­˜å™¨ï¼‰
- **ç«‹å³æ•°ï¼ˆimmediateï¼‰**ï¼š
  - é€šå¸¸ä¸º 32 ä½æœ‰ç¬¦å·æ•´æ•°ï¼ˆèŒƒå›´ `-2Â³Â¹ ~ 2Â³Â¹âˆ’1`ï¼‰
  - ä»…éƒ¨åˆ†æŒ‡ä»¤æ”¯æŒç«‹å³æ•°ï¼ˆå¦‚ `add`, `sub`, `mad`, `min`, `max`ï¼‰
- **æŒ‡ä»¤æ ¼å¼é€šå¼**ï¼š
  ```ptx
  instruction[.modifier].type d, a[, b[, c]];
  ```
- **çª„æ•´æ•°æ‰©å±•**ï¼š  
  `.s8/.u8/.s16/.u16` ä¸èƒ½ç›´æ¥ç”¨äºå¤§å¤šæ•°ç®—æœ¯æŒ‡ä»¤ï¼Œéœ€å…ˆé€šè¿‡ `cvt` æŒ‡ä»¤æ˜¾å¼æ‰©å±•è‡³ `.s32`/`.u32`ï¼š
  ```ptx
  cvt.s32.s16 %r1, %rh0;   // ç¬¦å·æ‰©å±• s16 â†’ s32
  cvt.u32.u8  %r2, %rb0;   // é›¶æ‰©å±• u8 â†’ u32
  ```

---

## ä¸€ã€åŸºæœ¬ç®—æœ¯è¿ç®—

### 1. `add` â€” åŠ æ³•
```ptx
add[.sat].type d, a, b;
```
- **åŠŸèƒ½**ï¼š`d = a + b`
- **æ”¯æŒç±»å‹**ï¼š
  - æ ‡é‡ï¼š`.s16`, `.u16`, `.s32`, `.u32`, `.s64`, `.u64`
  - å‘é‡ï¼ˆsm_90+ï¼‰ï¼š`.s16x2`, `.u16x2`
- **ä¿®é¥°ç¬¦**ï¼š
  - `.sat`ï¼šé¥±å’ŒåŠ æ³•ï¼ˆæº¢å‡ºæ—¶é’³ä½åˆ°ç±»å‹æœ€å¤§/æœ€å°å€¼ï¼‰ï¼Œä»…æ”¯æŒ `.s16`, `.u16`, `.s32`, `.u32`
- **æ³¨æ„**ï¼š
  - é»˜è®¤ wrap-aroundï¼ˆæ¨¡ 2â¿ï¼‰è¡Œä¸º
  - æ”¯æŒç«‹å³æ•°ï¼ˆ`b` å¯ä¸ºå¸¸é‡ï¼‰
- **ç¤ºä¾‹**ï¼š
  ```ptx
  add.s32    %r1, %r2, %r3;
  add.sat.u16 %rh1, %rh2, 100;
  add.u16x2  %r1, %r2, %r3;   // sm_90+
  ```

### 2. `sub` â€” å‡æ³•
```ptx
sub[.sat].type d, a, b;
```
- **åŠŸèƒ½**ï¼š`d = a - b`
- **æ”¯æŒç±»å‹**ï¼šåŒ `add`
- **ä¿®é¥°ç¬¦**ï¼š`.sat`ï¼ˆåŒä¸Šï¼‰
- **ç¤ºä¾‹**ï¼š
  ```ptx
  sub.u32 %r1, %r2, 100;
  ```

### 3. `mul` â€” ä¹˜æ³•
```ptx
mul.lo.type d, a, b;     // é»˜è®¤ï¼šå–ä½åŠéƒ¨åˆ†
mul.hi.type d, a, b;     // å–é«˜åŠéƒ¨åˆ†
mul.wide.type d, a, b;   // å…¨å®½ç»“æœï¼ˆåŒå€ä½å®½ï¼‰
```
- **åŠŸèƒ½**ï¼š
  - `mul.lo.s32 %r1, %r2, %r3;` â†’ `%r1 = (int64_t)%r2 * %r3 & 0xFFFFFFFF`
  - `mul.hi.u32 %r1, %r2, %r3;` â†’ `%r1 = ((uint64_t)%r2 * %r3) >> 32`
  - `mul.wide.s32 %rd1, %r2, %r3;` â†’ `%rd1` ä¸º `.s64`ï¼Œä¿å­˜å®Œæ•´ç§¯
- **æ”¯æŒç±»å‹**ï¼š
  - `.lo`/`.hi`ï¼šä»… `.s32`, `.u32`
  - `.wide`ï¼šä»… `.s32 â†’ .s64`, `.u32 â†’ .u64`
- **æ³¨æ„**ï¼š
  - **ä¸æ”¯æŒ `.s64`/`.u64` ä¹˜æ³•**ï¼ˆæ—  128 ä½å¯„å­˜å™¨ï¼‰
  - **ä¸æ”¯æŒç«‹å³æ•°**
- **ç¤ºä¾‹**ï¼š
  ```ptx
  mul.wide.u32 %rd1, %r2, %r3;
  ```

### 4. `mad` â€” èåˆä¹˜åŠ ï¼ˆMultiply-Addï¼‰
```ptx
mad.type d, a, b, c;
```
- **åŠŸèƒ½**ï¼š`d = (a * b) + c`
- **æ”¯æŒç±»å‹**ï¼š
  - `.s32`, `.u32`, `.s64`, `.u64`
  - å‘é‡ï¼ˆsm_90+ï¼‰ï¼š`.s16x2`, `.u16x2`
- **è¯­ä¹‰ç»†èŠ‚**ï¼š
  - å¯¹ `.s32`/`.u32`ï¼šä¹˜æ³•ä¸ºå…¨ç²¾åº¦ï¼Œç»“æœæ— ä¸­é—´èˆå…¥
  - å¯¹ `.s64`/`.u64`ï¼šä¹˜æ³•ç»“æœ **æˆªæ–­ä¸º 64 ä½**ï¼Œå†ä¸ `c` ç›¸åŠ ï¼ˆé 128 ä½èåˆï¼‰
- **ä¼˜åŠ¿**ï¼šæ¯” `mul + add` æ›´é«˜æ•ˆï¼Œé¿å…ä¸­é—´æº¢å‡ºå½±å“åŠ æ³•é¡ºåº
- **ç¤ºä¾‹**ï¼š
  ```ptx
  mad.u32 %r1, %r2, %r3, %r4;
  mad.s16x2 %r1, %r2, %r3, %r4;  // sm_90+
  ```

---

## äºŒã€24 ä½ä¸“ç”¨æŒ‡ä»¤ï¼ˆLegacyï¼‰

> åˆ©ç”¨æ—©æœŸ GPU çš„ 24 ä½ä¹˜æ³•å•å…ƒï¼Œç°ä»£æ¶æ„ä»æ”¯æŒä»¥å…¼å®¹æ—§ä»£ç ã€‚

### 5. `mul24` â€” 24 ä½ä¹˜æ³•
```ptx
mul24.type d, a, b;
```
- **åŠŸèƒ½**ï¼šå°† `a` å’Œ `b` çš„ä½ 24 ä½ç›¸ä¹˜ï¼Œç»“æœå–ä½ 32 ä½
- **æ”¯æŒç±»å‹**ï¼š`.s32`, `.u32`
- **è¡Œä¸º**ï¼š
  - è¾“å…¥é«˜ä½è¢«å¿½ç•¥
  - è¾“å‡ºä¸º 32 ä½ï¼ˆå¯èƒ½åŒ…å«è¿›ä½ï¼‰
- **ç¤ºä¾‹**ï¼š
  ```ptx
  mul24.u32 %r1, %r2, %r3;
  ```

### 6. `mad24` â€” 24 ä½èåˆä¹˜åŠ 
```ptx
mad24.type d, a, b, c;
```
- **åŠŸèƒ½**ï¼š`d = (a[23:0] * b[23:0]) + c`
- **æ”¯æŒç±»å‹**ï¼š`.s32`, `.u32`
- **æ³¨æ„**ï¼š`c` ä¸ºå®Œæ•´ 32 ä½ï¼Œç»“æœå¯èƒ½æº¢å‡º

---

## ä¸‰ã€ç‰¹æ®Šç®—æœ¯ä¸æ¯”è¾ƒ

### 7. `sad` â€” ç»å¯¹å·®ä¹‹å’Œï¼ˆSum of Absolute Differencesï¼‰
```ptx
sad.type d, a, b, c;
```
- **åŠŸèƒ½**ï¼š`d = c + |a - b|`
- **æ”¯æŒç±»å‹**ï¼šä»… `.u32`
- **ç”¨é€”**ï¼šè§†é¢‘ç¼–ç ã€å›¾åƒå¤„ç†
- **æ³¨æ„**ï¼š`|a - b|` = `max(a,b) - min(a,b)`ï¼ˆæ— ç¬¦å·ç»å¯¹å€¼ï¼‰
- **ç¤ºä¾‹**ï¼š
  ```ptx
  sad.u32 %r1, %r2, %r3, %r4;
  ```

### 8. `div` / `rem` â€” é™¤æ³•ä¸ä½™æ•°
```ptx
div.type d, a, b;
rem.type d, a, b;
```
- **åŠŸèƒ½**ï¼š
  - `div`: `d = a / b`ï¼ˆå‘é›¶å–æ•´ï¼‰
  - `rem`: `d = a % b`ï¼ˆæ»¡è¶³ `a = (a/b)*b + a%b`ï¼‰
- **æ”¯æŒç±»å‹**ï¼šä»… `.s32`, `.u32`
- **é™åˆ¶**ï¼š
  - **ä¸æ”¯æŒ 64 ä½æ•´æ•°é™¤æ³•**ï¼ˆç¡¬ä»¶æ— æ”¯æŒï¼Œç¼–è¯‘å™¨å›é€€åˆ°è½¯ä»¶æ¨¡æ‹Ÿï¼‰
  - é™¤é›¶è¡Œä¸ºæœªå®šä¹‰ï¼ˆå¯èƒ½å¯¼è‡´å¼‚å¸¸ï¼‰
- **ç¤ºä¾‹**ï¼š
  ```ptx
  div.s32 %r1, %r2, 10;
  ```

---

## å››ã€å•æ“ä½œæ•°å‡½æ•°

### 9. `abs` â€” ç»å¯¹å€¼
```ptx
abs.type d, a;
```
- **åŠŸèƒ½**ï¼š`d = |a|`
- **æ”¯æŒç±»å‹**ï¼š`.s32`, `.s64`
- **æ³¨æ„**ï¼šå¯¹ `INT_MIN` è¡Œä¸ºæœªå®šä¹‰ï¼ˆæ— æ³•è¡¨ç¤ºä¸ºæ­£æ•°ï¼‰

### 10. `neg` â€” å–è´Ÿ
```ptx
neg.type d, a;
```
- **åŠŸèƒ½**ï¼š`d = -a`
- **æ”¯æŒç±»å‹**ï¼š`.s32`, `.s64`
- **æ³¨æ„**ï¼šå¯¹ `INT_MIN` å–è´Ÿä»ä¸º `INT_MIN`ï¼ˆè¡¥ç ç‰¹æ€§ï¼‰

### 11. `min` / `max` â€” æœ€å°å€¼ / æœ€å¤§å€¼
```ptx
min[.relu].type d, a, b;
max[.relu].type d, a, b;
```
- **åŠŸèƒ½**ï¼šè¿”å› `a` å’Œ `b` çš„æœ€å°/æœ€å¤§å€¼
- **æ”¯æŒç±»å‹**ï¼š
  - æœ‰ç¬¦å·ï¼š`.s16`, `.s32`, `.s64`
  - æ— ç¬¦å·ï¼š`.u16`, `.u32`, `.u64`
  - å‘é‡ï¼ˆsm_90+ï¼‰ï¼š`.s16x2`, `.u16x2`
- **ä¿®é¥°ç¬¦**ï¼ˆPTX ISA 8.0+ï¼‰ï¼š
  - `.relu`ï¼š`result = max(0, op(a,b))` per laneï¼ˆç”¨äº AI æ¨ç†ï¼‰
- **ç¤ºä¾‹**ï¼š
  ```ptx
  max.relu.s16x2 %r1, %r2, %r3;  // sm_90+
  ```

---

## äº”ã€ä½è®¡æ•°ä¸æŸ¥æ‰¾

> æ‰€æœ‰æŒ‡ä»¤ç»“æœå¯„å­˜å™¨ç±»å‹ä¸º `.u32`

### 12. `popc` â€” Population Count
```ptx
popc.b32 d, a;
popc.b64 d, a;
```
- **åŠŸèƒ½**ï¼šç»Ÿè®¡ `a` ä¸­ 1 çš„ä¸ªæ•°
- **æ”¯æŒç±»å‹**ï¼š`.b32`, `.b64`

### 13. `clz` â€” Count Leading Zeros
```ptx
clz.b32 d, a;
clz.b64 d, a;
```
- **åŠŸèƒ½**ï¼šä» MSB å¼€å§‹è®¡æ•°è¿ç»­ 0ï¼›è‹¥ `a == 0`ï¼Œè¿”å› 32 æˆ– 64

### 14. `bfind` â€” Find Most Significant Non-Sign Bit
```ptx
bfind.type d, a;
```
- **åŠŸèƒ½**ï¼š
  - æ— ç¬¦å·ï¼šè¿”å›æœ€é«˜ä½ `1` çš„ä½ç½®ï¼ˆ0=LSBï¼‰
  - æœ‰ç¬¦å·ï¼šè¿”å›æœ€é«˜éç¬¦å·ä½ï¼ˆè·³è¿‡ç¬¦å·ä½åæœ€é«˜ä¸åŒä½ï¼‰
- **æ”¯æŒç±»å‹**ï¼š`.u32`, `.u64`, `.s32`, `.s64`
- **è¿”å›å€¼**ï¼šè‹¥ `a == 0`ï¼Œè¿”å› -1ï¼ˆ0xFFFFFFFFï¼‰

> âš ï¸ **æ—  `.lsb` å½¢å¼**ï¼›æŸ¥æ‰¾ LSB è¯·ç”¨ `fns.b32 d, a, 0`

### 15. `fns` â€” Find Next Set Bit
```ptx
fns.b32 d, a, b;
fns.b64 d, a, b;
```
- **åŠŸèƒ½**ï¼šä»ä½ `b`ï¼ˆå«ï¼‰å‘é«˜ä½æŸ¥æ‰¾ä¸‹ä¸€ä¸ªç½®ä½ä½
- **è¿”å›å€¼**ï¼šæ‰¾åˆ°åˆ™è¿”å›ä½ç´¢å¼•ï¼ˆ0~31/63ï¼‰ï¼›å¦åˆ™è¿”å› 32 æˆ– 64

### 16. `brev` â€” ä½åè½¬
```ptx
brev.b32 d, a;
brev.b64 d, a;
```
- **åŠŸèƒ½**ï¼šåè½¬ä½åºï¼ˆbit 0 â†” bit 31/63ï¼‰
- **ç”¨é€”**ï¼šFFTã€å“ˆå¸Œã€ä½é•œåƒ

---

## å…­ã€ä½åŸŸæ“ä½œ

### 17. `bfe` â€” Bit Field Extract
```ptx
bfe.type d, a, b, c;
```
- **åŠŸèƒ½**ï¼šä» `a` çš„ç¬¬ `b` ä½å¼€å§‹æå– `c` ä½ï¼Œç¬¦å·/é›¶æ‰©å±•è‡³ 32 ä½
- **æ”¯æŒç±»å‹**ï¼š`.s32`ï¼ˆç¬¦å·æ‰©å±•ï¼‰, `.u32`ï¼ˆé›¶æ‰©å±•ï¼‰
- **çº¦æŸ**ï¼š
  - `b âˆˆ [0, 31]`, `c âˆˆ [1, 32]`
  - è‹¥ `b + c > 32`ï¼Œé«˜ä½è§†ä¸º 0ï¼ˆ`.u32`ï¼‰æˆ–ç¬¦å·ä½ï¼ˆ`.s32`ï¼‰

### 18. `bfi` â€” Bit Field Insert
```ptx
bfi.b32 d, a, b, c, e;
```
- **åŠŸèƒ½**ï¼šå°† `a` çš„ä½ `e` ä½æ’å…¥ `b` çš„ç¬¬ `c` ä½èµ·å§‹ä½ç½®
- **å…¬å¼**ï¼š`d = (b & ~mask) | ((a << c) & mask)`
- **çº¦æŸ**ï¼š`c + e â‰¤ 32`

### 19. `bmsk` â€” Bit Mask Generation
```ptx
bmsk.b32 d, a;
```
- **åŠŸèƒ½**ï¼šç”Ÿæˆä½ `a+1` ä½ä¸º 1 çš„æ©ç 
- **å…¬å¼**ï¼š`d = (1 << (a + 1)) - 1`ï¼›è‹¥ `a â‰¥ 31`ï¼Œ`d = 0xFFFFFFFF`

---

## ä¸ƒã€ç‚¹ç§¯åŠ é€ŸæŒ‡ä»¤ï¼ˆTensor Coreï¼‰

> åˆ©ç”¨ INT4/INT8 å¼ é‡æ ¸å¿ƒè¿›è¡Œ SIMD ç‚¹ç§¯ï¼Œå¹¿æ³›ç”¨äºé‡åŒ–æ¨ç†ï¼ˆéœ€ `sm_61+`ï¼‰

### 20. `dp4a` â€” 4 é€šé“ 8 ä½ç‚¹ç§¯ç´¯åŠ 
```ptx
dp4a.type d, a, b, c;
```
- **åŠŸèƒ½**ï¼š`d = c + Î£_{i=0}^3 (a_i * b_i)`
- **æ•°æ®å¸ƒå±€**ï¼š`a`, `b` ä¸º 32 ä½ï¼Œå« 4 ä¸ª packed int8ï¼ˆå°ç«¯ï¼‰
- **æ”¯æŒç±»å‹**ï¼š`.s32`ï¼ˆå…¨é€šé“æœ‰ç¬¦å·ï¼‰, `.u32`ï¼ˆå…¨é€šé“æ— ç¬¦å·ï¼‰
- **ç¤ºä¾‹**ï¼š
  ```ptx
  dp4a.s32 %r1, %r2, %r3, %r4;
  ```

### 21. `dp2a` â€” 2 é€šé“ 16Ã—8 ä½ç‚¹ç§¯
```ptx
dp2a.type d, a, b, c;
```
- **åŠŸèƒ½**ï¼š`d = c + a_lo * b_lo + a_hi * b_hi`
- **å¸ƒå±€**ï¼š
  - `a`: ä¸¤ä¸ª 16 ä½æ•´æ•°ï¼ˆ`[15:0]`, `[31:16]`ï¼‰
  - `b`: ä¸¤ä¸ª 8 ä½æ•´æ•°ï¼ˆ`[7:0]`, `[15:8]`ï¼‰ï¼Œé«˜ä½è¡¥é›¶/ç¬¦å·æ‰©å±•
- **æ”¯æŒç±»å‹**ï¼š`.s32`, `.u32`

---

## æ€»ç»“è¡¨ï¼šæ•´æ•°ç®—æœ¯æŒ‡ä»¤æ¦‚è§ˆ

| æŒ‡ä»¤ | æ“ä½œæ•° | ç±»å‹æ”¯æŒ | ç‰¹æ€§ |
|------|--------|--------|------|
| `add`/`sub` | 2 | `.s16/.u16/.s32/.u32/.s64/.u64` + `.s16x2/.u16x2`ï¼ˆsm_90ï¼‰ | æ”¯æŒ `.sat`ã€ç«‹å³æ•° |
| `mul` | 2 | `.s32/.u32`ï¼ˆ`.lo`/`.hi`/`.wide`ï¼‰ | æ—  64 ä½ä¹˜ |
| `mad` | 3 | `.s32/.u32/.s64/.u64` + `.s16x2/.u16x2` | èåˆä¹˜åŠ  |
| `mul24`/`mad24` | 2/3 | `.s32/.u32` | 24 ä½ä¼˜åŒ–ï¼ˆlegacyï¼‰ |
| `sad` | 3 | `.u32` | SAD |
| `div`/`rem` | 2 | `.s32/.u32` | æ—  64 ä½é™¤æ³• |
| `abs`/`neg` | 1 | `.s32/.s64` | å•ç›® |
| `min`/`max` | 2 | `.s16/.u16/.s32/.u32/.s64/.u64` + `.s16x2/.u16x2` | æ”¯æŒ `.relu`ï¼ˆsm_90ï¼‰ |
| `popc`/`clz`/`brev`/`fns` | 1â€“2 | `.b32/.b64` | ä½åˆ†æ |
| `bfind` | 1 | `.s32/.u32/.s64/.u64` | æŸ¥æ‰¾ MSB |
| `bfe`/`bfi`/`bmsk` | 2â€“4 | `.s32/.u32/.b32` | ä½åŸŸ |
| `dp4a`/`dp2a` | 3 | `.s32/.u32` | SIMD ç‚¹ç§¯ï¼ˆsm_61+ï¼‰ |

---

## âœ… æœ€ä½³å®è·µ

- **ä¼˜å…ˆä½¿ç”¨ `mad`** è€Œé `mul + add`ï¼Œæå‡æ€§èƒ½ä¸æ•°å€¼ç¨³å®šæ€§ã€‚
- **é¿å… 64 ä½é™¤æ³•**ï¼šæ— ç¡¬ä»¶æ”¯æŒï¼Œä¼šè§¦å‘æ˜‚è´µçš„è½¯ä»¶æ¨¡æ‹Ÿã€‚
- **é‡åŒ–æ¨ç†ä¸­å¤§é‡ä½¿ç”¨ `dp4a`** åŠ é€Ÿ int8 çŸ©é˜µä¹˜ã€‚
- **çª„æ•´æ•°åŠ¡å¿…å…ˆ `cvt` æ‰©å±•**ï¼Œä¸å¯ç›´æ¥ç”¨äºç®—æœ¯æŒ‡ä»¤ã€‚
- **åˆ©ç”¨ `.s16x2` + `.relu`** åœ¨ `sm_90` ä¸Šé«˜æ•ˆå®ç° ReLU æ¿€æ´»ã€‚

> ğŸ“š **å‚è€ƒ**ï¼š[NVIDIA PTX ISA 9.1, Section 9.7.1 â€œInteger Arithmetic Instructionsâ€](https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#integer-arithmetic-instructions)